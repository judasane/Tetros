--- FLATTENED REPOSITORY SOURCE ---
Generated at: Wed Sep 24 15:26:16 UTC 2025
Branch: main
Commit: bab593fe0dc577439e20b72c65a80a5e9bc4dcc3
------------------------------------

--- START OF FILE: .github/workflows/deploy.yml ---
name: Deploy to GitHub Pages
on:
  push:
    branches:
      - main
permissions:
  contents: read
  pages: write
  id-token: write
concurrency:
  group: "pages"
  cancel-in-progress: false
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm install
      - name: Build
        run: npm run build -- --base-href /${{ github.event.repository.name }}/
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./dist  # Quitar el /* - debe ser solo la carpeta
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

--- END OF FILE: .github/workflows/deploy.yml ---

--- START OF FILE: .github/workflows/flatten.yml ---
name: Create Flattened File

on:
  workflow_dispatch:

jobs:
  flatten-and-commit:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate flattened file
        run: |
          OUTPUT_FILE="flattened_output.txt"
          # Add or remove file extensions to exclude
          EXCLUDE_EXTENSIONS="map,tsbuildinfo,log,lock,db,sqlite,sqlite3,dump,lcov,png,jpg,jpeg,gif,ico,zip,gz,pdf,mp4,svg"
          # Add or remove specific filenames to exclude
          EXCLUDE_FILES="package-lock.json,yarn.lock,pnpm-lock.yaml"

          echo "--- FLATTENED REPOSITORY SOURCE ---" > "$OUTPUT_FILE"
          echo "Generated at: $(date)" >> "$OUTPUT_FILE"
          echo "Branch: ${GITHUB_REF##*/}" >> "$OUTPUT_FILE"
          echo "Commit: ${GITHUB_SHA}" >> "$OUTPUT_FILE"
          echo "------------------------------------" >> "$OUTPUT_FILE"
          echo "" >> "$OUTPUT_FILE"

          exclude_ext_pattern=$(echo "$EXCLUDE_EXTENSIONS" | sed 's/,/|/g')
          # Also exclude the output file itself
          exclude_files_pattern="$OUTPUT_FILE|$(echo "$EXCLUDE_FILES" | sed 's/,/|/g')"

          git ls-files | \
          grep -vE "\.($exclude_ext_pattern)$" | \
          grep -vE "^($exclude_files_pattern)$" | \
          while IFS= read -r file; do
              echo "--- START OF FILE: $file ---" >> "$OUTPUT_FILE"
              cat "$file" >> "$OUTPUT_FILE"
              echo -e "\n--- END OF FILE: $file ---\n" >> "$OUTPUT_FILE"
          done

          echo "âœ… Repository flattened into $OUTPUT_FILE"

      - name: Commit and push flattened file
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add $OUTPUT_FILE
          # Check if there are changes to commit to avoid empty commits
          if git diff --staged --quiet; then
            echo "No changes to commit. The flattened file is already up-to-date."
          else
            git commit -m "docs: Add/update flattened repository file" -m "This commit was generated by a GitHub Action."
            git push
          fi
        env:
          OUTPUT_FILE: "flattened_output.txt"

      - name: Upload artifact for easy download
        uses: actions/upload-artifact@v4
        with:
          name: flattened-repository-file
          path: flattened_output.txt
          if-no-files-found: error

--- END OF FILE: .github/workflows/flatten.yml ---

--- START OF FILE: .gitignore ---
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Angular cache
.angular/cache

--- END OF FILE: .gitignore ---

--- START OF FILE: .idx/dev.nix ---
{ pkgs }: {
  channel = "stable-24.11";
  packages = [
    pkgs.nodejs_22
  ];
  idx.extensions = [
    "angular.ng-template"
  ];
  idx.previews = {
    previews = {
      web = {
        command = [
          "npm"
          "run"
          "dev"
          "--"
          "--port"
          "$PORT"
          "--host"
          "0.0.0.0"
        ];
        manager = "web";
      };
    };
  };
}

--- END OF FILE: .idx/dev.nix ---

--- START OF FILE: README.md ---
# Tetros: El Tejedor CÃ³smico

> *En la vasta y silenciosa expansiÃ³n donde nacen las estrellas y se desvanecen las galaxias, existe un telar de energÃ­a cÃ³smica. TÃº, alma valiente, eres el Tejedor, encargado de un deber eterno: dar forma al tejido mismo de la realidad a partir de fragmentos de luz estelar que caen.*

**Tetros** no es un simple juego; es una prueba de concentraciÃ³n, una danza de creaciÃ³n y disoluciÃ³n al borde del vacÃ­o. A medida que los bloques celestiales â€”los restos de estrellas moribundasâ€” descienden de los cielos, debes guiarlos, rotarlos y alinearlos en perfectos e ininterrumpidos filamentos cÃ³smicos.

Si fallas, el caos consumirÃ¡ el tablero. Si tienes Ã©xito, traerÃ¡s orden al universo, una lÃ­nea resplandeciente a la vez.

---
## El Arcano: Blandiendo Poderes EtÃ©reos

El cosmos ayuda a quienes demuestran su valÃ­a. Al alinear los filamentos, desbloquearÃ¡s potentes habilidades, poderosos encantamientos para doblegar la realidad a tu voluntad:

*   âš¡ï¸ **Rayo Celestial:** Desata un penetrante rayo de energÃ­a pura para aniquilar una lÃ­nea obstinada de la existencia.
*   â³ **Flujo Temporal:** Doblega el flujo del tiempo mismo, haciendo que los fragmentos de estrellas desciendan con una lentitud etÃ©rea.
*   âœ¨ **TransmutaciÃ³n CaÃ³tica:** Invoca la naturaleza impredecible del vacÃ­o, remodelando instantÃ¡neamente el fragmento que cae en una nueva forma.
*   ðŸ“¦ **Convergencia Destinada:** Contempla el tejido del destino, apuntando y eliminando con precisiÃ³n un Ãºnico bloque mal colocado para restaurar el equilibrio.

---
## Las Incantaciones: Controles del Tejedor

Para comandar los fragmentos celestiales, debes dominar estos antiguos ritos:

| Tecla(s)    | AcciÃ³n                      |
|-------------|-----------------------------|
| `â—„ â–º`       | Mover Fragmento Lateralmente|
| `â–²`         | Rotar Fragmento             |
| `â–¼`         | Acelerar Descenso           |
| `Espacio`   | Zambullida en el Abismo     |
| `C`         | Secuestrar Fragmento (Hold) |
| `P`         | Suspender el Tiempo (Pausa) |
| `1` - `4`   | Invocar Poder               |

---
## La InvocaciÃ³n: CÃ³mo Comenzar Tu Prueba

1.  Abre el portal arcano (tu navegador web).
2.  Concentra tu voluntad.
3.  Presiona **Start Game**.
4.  Teje tu destino.

> *El universo espera a su maestro. Â¿AceptarÃ¡s el desafÃ­o o te perderÃ¡s en la interminable cascada del caos?*
--- END OF FILE: README.md ---

--- START OF FILE: angular.json ---
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "",
  "projects": {
    "app": {
      "projectType": "application",
      "root": "",
      "sourceRoot": "./",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular/build:application",
          "options": {
            "outputPath": {
              "base": "./dist",
              "browser": "."
            },
            "browser": "index.tsx",
            "tsConfig": "tsconfig.json",
            "assets": [
              {
                "glob": "**/*",
                "input": "public",
                "output": "."
              }
            ]
          },
          "configurations": {
            "production": {
              "outputHashing": "all",
              "serviceWorker": "ngsw-config.json"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular/build:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "app:build:production"
            },
            "development": {
              "buildTarget": "app:build:development"
            }
          },
          "defaultConfiguration": "development"
        }
      }
    }
  }
}
--- END OF FILE: angular.json ---

--- START OF FILE: index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Tetros</title>
  <base href="/"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="theme-color" content="#0f172a">
  <link rel="icon" type="image/x-icon" href="favicon.ico"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom font for a game-like feel */
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    body {
      font-family: 'Press Start 2P', cursive;
      overflow: hidden;
    }

    @keyframes line-clear-flash {
      0%, 100% { 
        background-color: white; 
        transform: scale(1.05); 
        border-color: white;
      }
      50% { 
        background-color: #67e8f9; /* Tailwind cyan-300 */
        transform: scale(1.0); 
      }
    }
    .animate-line-clear {
      animation: line-clear-flash 0.3s ease-out;
    }
  </style>
<script type="importmap">
{
  "imports": {
    "rxjs": "https://aistudiocdn.com/rxjs@^7.8.2?conditions=es2015",
    "rxjs/operators": "https://aistudiocdn.com/rxjs@^7.8.2/operators?conditions=es2015",
    "rxjs/ajax": "https://aistudiocdn.com/rxjs@^7.8.2/ajax?conditions=es2015",
    "rxjs/webSocket": "https://aistudiocdn.com/rxjs@^7.8.2/webSocket?conditions=es2015",
    "rxjs/testing": "https://aistudiocdn.com/rxjs@^7.8.2/testing?conditions=es2015",
    "rxjs/fetch": "https://aistudiocdn.com/rxjs@^7.8.2/fetch?conditions=es2015",
    "@angular/platform-browser": "https://next.esm.sh/@angular/platform-browser@^20.1.6-0?external=rxjs",
    "@angular/core": "https://next.esm.sh/@angular/core@^20.1.6-0?external=rxjs",
    "@angular/compiler": "https://next.esm.sh/@angular/compiler@^20.1.6-0?external=rxjs",
    "@angular/common/http": "https://next.esm.sh/@angular/common@^20.1.6-0/http?external=rxjs"
  }
}
</script>
  <link rel="manifest" href="manifest.webmanifest">
</head>
<body class="bg-slate-900 text-white">
  <app-root></app-root>
  <noscript>Please enable JavaScript to continue using this application.</noscript>
</body>
</html>
--- END OF FILE: index.html ---

--- START OF FILE: index.tsx ---

import '@angular/compiler';
import { bootstrapApplication } from '@angular/platform-browser';
import { provideHttpClient } from '@angular/common/http';
import { provideZonelessChangeDetection, isDevMode } from '@angular/core';

import { AppComponent } from './src/app.component';
import { provideServiceWorker } from '@angular/service-worker';

bootstrapApplication(AppComponent, {
  providers: [
    provideZonelessChangeDetection(),
    provideHttpClient(), provideServiceWorker('ngsw-worker.js', {
            enabled: !isDevMode(),
            registrationStrategy: 'registerWhenStable:30000'
          }),
  ],
}).catch(err => console.error(err));

// AI Studio always uses an `index.tsx` file for all project types.

--- END OF FILE: index.tsx ---

--- START OF FILE: metadata.json ---
{
  "name": "Tetros",
  "description": "A modern twist on the classic Tetris game, combining falling block puzzles with exciting power-ups. Clear lines, level up, and use special abilities like lasers and slow motion to achieve a high score.",
  "requestFramePermissions": []
}
--- END OF FILE: metadata.json ---

--- START OF FILE: ngsw-config.json ---
{
  "$schema": "./node_modules/@angular/service-worker/config/schema.json",
  "index": "index.html",
  "assetGroups": [
    {
      "name": "app",
      "installMode": "prefetch",
      "resources": {
        "files": [
          "favicon.ico",
          "index.html",
          "manifest.webmanifest",
          "*.css",
          "*.js"
        ]
      }
    },
    {
      "name": "assets",
      "installMode": "lazy",
      "updateMode": "prefetch",
      "resources": {
        "files": [
          "/**/*.{svg,cur,jpg,jpeg,png,apng,webp,avif,gif,otf,ttf,woff,woff2}"
        ]
      }
    }
  ]
}

--- END OF FILE: ngsw-config.json ---

--- START OF FILE: package.json ---
{
  "name": "tetros",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "ng serve",
    "build": "ng build",
    "preview": "ng serve --configuration=production",
    "test": "vitest"
  },
  "dependencies": {
    "@angular/build": "^20.1.0",
    "@angular/cli": "^20.1.0",
    "@angular/common": "^20.1.0",
    "@angular/compiler": "^20.1.0",
    "@angular/compiler-cli": "^20.1.0",
    "@angular/core": "^20.1.0",
    "@angular/platform-browser": "^20.1.0",
    "@angular/platform-browser-dynamic": "^20.1.0",
    "@angular/service-worker": "^20.1.0",
    "rxjs": "^7.8.2",
    "tailwindcss": "latest",
    "zone.js": "^0.15.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0",
    "vitest": "^3.1.1",
    "jsdom": "^24.1.1",
    "@analogjs/vite-plugin-angular": "^1.9.0"
  }
}
--- END OF FILE: package.json ---

--- START OF FILE: public/manifest.webmanifest ---
{
  "name": "Tetros",
  "short_name": "Tetros",
  "description": "Un juego de Tetris moderno",
  "theme_color": "#0f172a",
  "background_color": "#0f172a",
  "display": "standalone",
  "scope": "./",
  "start_url": "./",
  "icons": [
    {
      "src": "icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ]
}

--- END OF FILE: public/manifest.webmanifest ---

--- START OF FILE: src/app.component.css ---
/* Component-specific styles for AppComponent can go here. */

--- END OF FILE: src/app.component.css ---

--- START OF FILE: src/app.component.html ---
<div class="flex flex-col items-center justify-center min-h-screen p-2 sm:p-4 bg-slate-900 text-sm">

  <!-- Game Wrapper - A row on all screen sizes, centered on the page -->
  <div class="flex flex-row gap-4 items-start">
  
    <!-- Left Column -->
    <div class="flex flex-col gap-4">
      
      <!-- Powerups Panel -->
      <div [style.width.px]="boardWidth()">
        <app-info-panel title="PowerUps">
            <div class="grid grid-cols-4 gap-2 text-center">
                <button (click)="game.activatePowerUp('laser')" [disabled]="!game.canUsePowerUp('laser')" class="p-2 border-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed h-12 flex justify-center items-center" [class]="game.canUsePowerUp('laser') ? 'border-red-500 text-red-500 hover:bg-red-500/20' : 'border-slate-600 text-slate-600'">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" /></svg>
                </button>
                <button (click)="game.activatePowerUp('slow')" [disabled]="!game.canUsePowerUp('slow')" class="p-2 border-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed h-12 flex justify-center items-center" [class]="game.canUsePowerUp('slow') ? 'border-blue-500 text-blue-500 hover:bg-blue-500/20' : 'border-slate-600 text-slate-600'">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                </button>
                <button (click)="game.activatePowerUp('mutate')" [disabled]="!game.canUsePowerUp('mutate')" class="p-2 border-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed h-12 flex justify-center items-center" [class]="game.canUsePowerUp('mutate') ? 'border-purple-500 text-purple-500 hover:bg-purple-500/20' : 'border-slate-600 text-slate-600'">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.562L16.5 21.75l-.398-1.188a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.188-.398a2.25 2.25 0 001.423-1.423L16.5 15.75l.398 1.188a2.25 2.25 0 001.423 1.423L19.5 18.75l-1.188.398a2.25 2.25 0 00-1.423 1.423z" /></svg>
                </button>
                <button (click)="game.activatePowerUp('aimer')" [disabled]="!game.canUsePowerUp('aimer')" class="p-2 border-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed h-12 flex justify-center items-center" [class]="game.canUsePowerUp('aimer') ? 'border-yellow-500 text-yellow-500 hover:bg-yellow-500/20' : 'border-slate-600 text-slate-600'">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 7.5l-9-5.25L3 7.5m18 0l-9 5.25m9-5.25v9l-9 5.25M3 7.5l9 5.25M3 7.5v9l9 5.25m0-9v9" /></svg>
                </button>
            </div>
        </app-info-panel>
      </div>

      <!-- Game Board & Overlay -->
      <div 
        class="relative shadow-2xl shadow-cyan-500/20 border-4 border-slate-700 rounded-lg"
        (touchstart)="handleTouchStart($event)"
        (touchmove)="handleTouchMove($event)"
        (touchend)="handleTouchEnd($event)">
        <app-board 
            [board]="game.board()" 
            [currentPiece]="game.currentPiece()" 
            [ghostPiece]="game.ghostPiece()"
            [animationMode]="game.animationMode()"
            [dropProgress]="game.dropProgress()"
            [cellSize]="cellSize()"
             />
        <app-game-overlay 
            [gameState]="game.gameState()"
            [countdownValue]="game.countdownValue()"
            [animationMode]="game.animationMode()"
            (start)="game.startGame()" 
            (restart)="game.startGame()"
            (togglePause)="game.togglePause()"
            (toggleAnimation)="game.toggleAnimationMode()"
             />
      </div>
    </div>

    <!-- Right Column -->
    <div class="flex flex-col" [style.width.px]="boardWidth() / 3">
      
      <!-- Combined Info Panel -->
      <div class="w-full">
        <app-info-panel>
            <div class="flex flex-col justify-around items-center gap-4 py-2">
                <div class="flex flex-col items-center">
                    <h4 class="text-xs text-slate-400 mb-2 uppercase">Hold</h4>
                    @if (game.holdPiece(); as piece) {
                        <app-piece-preview [piece]="piece.shape" />
                    } @else {
                        <div class="w-16 h-12 flex items-center justify-center text-slate-600 text-xs rounded-md bg-slate-900/50">Empty</div>
                    }
                </div>
                <div class="flex flex-col items-center">
                    <h4 class="text-xs text-slate-400 mb-2 uppercase">Next</h4>
                    @if (game.nextPiece(); as piece) {
                        <app-piece-preview [piece]="piece.shape" />
                    } @else {
                        <div class="w-16 h-12 flex items-center justify-center text-slate-600 text-xs rounded-md bg-slate-900/50">Empty</div>
                    }
                </div>
                 <div class="flex flex-col items-center">
                      <h4 class="text-xs text-slate-400 mb-2 uppercase">Score</h4>
                      <p class="text-base lg:text-xl text-yellow-300">{{ game.score() }}</p>
                  </div>
                  <div class="flex flex-col items-center">
                      <h4 class="text-xs text-slate-400 mb-2 uppercase">Level</h4>
                      <p class="text-base lg:text-xl text-green-400">{{ game.level() }}</p>
                  </div>
                  <div class="flex flex-col items-center">
                      <h4 class="text-xs text-slate-400 mb-2 uppercase">Lines</h4>
                      <p class="text-base lg:text-xl text-purple-400">{{ game.linesCleared() }}</p>
                  </div>
            </div>
        </app-info-panel>
      </div>
      
    </div>
  </div>
</div>
--- END OF FILE: src/app.component.html ---

--- START OF FILE: src/app.component.ts ---
/**
 * @fileoverview Root component for the Tetros application.
 */
import { ChangeDetectionStrategy, Component, inject, signal, OnInit, computed } from '@angular/core';
import { GameFacade } from './services/game.facade';
import { BoardComponent } from './components/board/board.component';
import { GameOverlayComponent } from './components/game-overlay/game-overlay.component';
import { InfoPanelComponent } from './components/info-panel/info-panel.component';
import { PiecePreviewComponent } from './components/piece-preview/piece-preview.component';
import { COLS, ROWS } from './utils/constants';

/**
 * The main application component.
 * It assembles the game's UI components and handles global keyboard and touch events for game control.
 */
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [
    BoardComponent,
    GameOverlayComponent,
    InfoPanelComponent,
    PiecePreviewComponent,
  ],
  providers: [],
  host: {
    '(window:keydown)': 'handleKeyDown($event)',
    '(window:keyup)': 'handleKeyUp($event)',
    '(window:resize)': 'updateCellSize()'
  }
})
export class AppComponent implements OnInit {
  /** Injected instance of the GameFacade, which provides a simplified interface to the game systems. */
  game = inject(GameFacade);

  /** The dynamically calculated size of a single board cell in pixels. */
  cellSize = signal(32);

  /** A signal indicating if the viewport is wide enough for the desktop layout. */
  isDesktop = signal(window.innerWidth >= 768);

  /** A computed signal for the total width of the game board in pixels. */
  boardWidth = computed(() => COLS * this.cellSize());

  // --- Touch Gesture State ---
  private touchStartX = 0;
  private touchStartY = 0;
  private touchStartTime = 0;
  private lastMoveX = 0;
  private lastMoveY = 0;
  private readonly swipeThreshold = 30; // Min pixels for a swipe
  private readonly tapThreshold = 20;   // Max pixels for a tap
  private readonly tapTimeThreshold = 200; // Max ms for a tap
  private readonly hardDropTimeThreshold = 250; // Max ms for a hard drop swipe
  
  /**
   * Initializes the component and performs the initial cell size calculation.
   */
  ngOnInit(): void {
    this.updateCellSize();
  }
  
  /**
   * Calculates and updates the optimal cell size based on the window's dimensions.
   * This logic assumes a persistent two-column layout.
   */
  updateCellSize(): void {
    this.isDesktop.set(window.innerWidth >= 768);

    // The layout is always a two-column flexbox.
    // The total game area width is ~4/3 of the board's width. Let's use 95% of the viewport width.
    const availableWidth = window.innerWidth * 0.95;
    // The board's container (left column) takes up roughly 3/4 of that space.
    const boardContainerWidth = availableWidth * 0.75;

    // Use 90% of the viewport height for the game area.
    const availableHeight = window.innerHeight * 0.90;
    
    // Calculate cell size based on available width for the board.
    const sizeByWidth = boardContainerWidth / COLS;
    // Calculate cell size based on available height, estimating space for the power-ups panel.
    // The powerups + board height is roughly equivalent to ROWS + 4 cells vertically.
    const sizeByHeight = availableHeight / (ROWS + 4); 
    
    this.cellSize.set(Math.floor(Math.min(sizeByHeight, sizeByWidth)));
  }

  /**
   * Handles the global 'keydown' event to process player inputs.
   * @param event The KeyboardEvent triggered by the key press.
   */
  handleKeyDown(event: KeyboardEvent): void {
    if (event.repeat) return;

    // Handle global controls like start and pause
    if (this.game.gameState() === 'start' && event.key === 'Enter') {
      this.game.startGame();
      return;
    }
    if ((this.game.gameState() === 'playing' || this.game.gameState() === 'paused') && (event.key === 'p' || event.key === 'P')) {
      this.game.togglePause();
      return;
    }

    // Delegate all other game-related key presses to the input service via the facade
    this.game.pressKey(event.key);
  }

  /**
   * Handles the global 'keyup' event to stop continuous actions.
   * @param event The KeyboardEvent triggered by the key release.
   */
  handleKeyUp(event: KeyboardEvent): void {
    this.game.releaseKey(event.key);
  }

  /**
   * Records the starting coordinates of a touch event.
   * @param event The TouchEvent.
   */
  handleTouchStart(event: TouchEvent): void {
    if (this.game.gameState() !== 'playing') return;
    event.preventDefault();
    this.touchStartX = event.touches[0].clientX;
    this.touchStartY = event.touches[0].clientY;
    this.touchStartTime = Date.now();
    this.lastMoveX = this.touchStartX;
    this.lastMoveY = this.touchStartY;
  }

  /**
   * Processes touch movement to detect and handle swipes.
   * @param event The TouchEvent.
   */
  handleTouchMove(event: TouchEvent): void {
    if (this.game.gameState() !== 'playing') return;
    event.preventDefault();
    const touchX = event.touches[0].clientX;
    const touchY = event.touches[0].clientY;

    const deltaX = touchX - this.lastMoveX;
    const deltaY = touchY - this.lastMoveY;
    
    const horizontalMoveThreshold = this.cellSize() * 0.8;
    const verticalMoveThreshold = this.cellSize() * 0.8;

    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > horizontalMoveThreshold) {
      if (deltaX > 0) this.game.moveRight();
      else this.game.moveLeft();
      this.lastMoveX = touchX;
    } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > verticalMoveThreshold) {
      this.game.softDrop();
      this.lastMoveY = touchY;
    }
  }

  /**
   * Processes the end of a touch to detect taps and hard drops.
   * @param event The TouchEvent.
   */
  handleTouchEnd(event: TouchEvent): void {
    if (this.game.gameState() !== 'playing') return;
    event.preventDefault();
    const touchEndX = event.changedTouches[0].clientX;
    const touchEndY = event.changedTouches[0].clientY;

    const deltaX = touchEndX - this.touchStartX;
    const deltaY = touchEndY - this.touchStartY;
    const elapsedTime = Date.now() - this.touchStartTime;

    // Check for Tap (Rotate)
    if (Math.abs(deltaX) < this.tapThreshold && Math.abs(deltaY) < this.tapThreshold && elapsedTime < this.tapTimeThreshold) {
      this.game.rotate();
      return;
    }

    // Check for Hard Drop (fast, long downward swipe)
    if (deltaY > this.swipeThreshold * 2.5 && deltaY > Math.abs(deltaX) && elapsedTime < this.hardDropTimeThreshold) {
      this.game.hardDrop();
      return;
    }
  }
}
--- END OF FILE: src/app.component.ts ---

--- START OF FILE: src/components/board/board.component.css ---
/* Component-specific styles for BoardComponent can go here. */

--- END OF FILE: src/components/board/board.component.css ---

--- START OF FILE: src/components/board/board.component.html ---
<div 
  class="relative bg-slate-800/50 overflow-hidden grid" 
  [style.grid-template-columns]="'repeat(' + COLS + ', ' + cellSize() + 'px)'"
  [style.width.px]="COLS * cellSize()"
>
  <!-- The static board grid for locked pieces -->
  @for (row of boardToRender(); track $index) {
    @for (cell of row; track $index) {
      <app-cell [value]="cell" />
    }
  }

  <!-- The smoothly animated ghost piece -->
  @if (ghostPiece(); as ghost) {
    <app-falling-piece 
        [piece]="ghost" 
        [isGhost]="true" 
        [animationMode]="animationMode()"
        [cellSize]="cellSize()"
        />
  }

  <!-- The smoothly animated current piece -->
  @if (currentPiece(); as piece) {
    <app-falling-piece 
        [piece]="piece"
        [animationMode]="animationMode()"
        [dropProgress]="dropProgress()"
        [cellSize]="cellSize()"
        />
  }
</div>

--- END OF FILE: src/components/board/board.component.html ---

--- START OF FILE: src/components/board/board.component.ts ---
/**
 * @fileoverview Component for rendering the main game board.
 */
import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';
import { CellComponent } from '../cell/cell.component';
import { COLS } from '../../utils/constants';
import { Piece } from '../../utils/piece.interface';
import { FallingPieceComponent } from '../falling-piece/falling-piece.component';

/**
 * Renders the game board, including the static grid of locked pieces
 * and the animated falling and ghost pieces.
 */
@Component({
  selector: 'app-board',
  standalone: true,
  imports: [CellComponent, FallingPieceComponent],
  templateUrl: './board.component.html',
  styleUrls: ['./board.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class BoardComponent {
  /** The number of columns on the board. */
  readonly COLS = COLS;
  
  /** The 2D array representing the static, locked-in pieces on the board. */
  boardInput = input.required<number[][]>({ alias: 'board' });
  
  /** The currently falling piece, or null if none. */
  currentPiece = input.required<Piece | null>();
  
  /** The ghost piece showing the final drop position, or null if none. */
  ghostPiece = input.required<Piece | null>();

  /** The user-selected animation mode for piece movement. */
  animationMode = input<'step' | 'smooth'>('smooth');

  /** The fractional progress of the current piece's drop between two cells (0 to 1), used for smooth animation. */
  dropProgress = input<number>(0);

  /** The size of a single cell in pixels, used for dynamic board scaling. */
  cellSize = input<number>(32);

  /** A computed signal that directly passes the board input to the template. */
  boardToRender = computed(() => this.boardInput());
}

--- END OF FILE: src/components/board/board.component.ts ---

--- START OF FILE: src/components/cell/cell.component.css ---
/* Component-specific styles for CellComponent can go here. */

--- END OF FILE: src/components/cell/cell.component.css ---

--- START OF FILE: src/components/cell/cell.component.html ---
<div 
  class="aspect-square border border-slate-700/50" 
  [class]="cellClass()">
</div>

--- END OF FILE: src/components/cell/cell.component.html ---

--- START OF FILE: src/components/cell/cell.component.ts ---
/**
 * @fileoverview Component for a single cell on the game board.
 */
import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';
import { PIECE_COLORS } from '../../utils/constants';

/**
 * Represents a single cell in the game grid. Its appearance is determined
 * by the numeric `value` input.
 */
@Component({
  selector: 'app-cell',
  standalone: true,
  templateUrl: './cell.component.html',
  styleUrls: ['./cell.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CellComponent {
  /** 
   * The numeric value of the cell which determines its state and appearance.
   * - `0`: Empty
   * - `> 0`: A locked piece, value corresponds to a color index.
   * - `-1`: Ghost piece preview.
   * - `-2`: Aimer power-up target.
   * - `-3`: Part of a line being cleared.
   */
  value = input.required<number>();

  /**
   * Computes the appropriate Tailwind CSS classes for the cell based on its value.
   * @returns A string of CSS classes.
   */
  cellClass = computed(() => {
    const val = this.value();
    if (val > 0) {
      // Piece
      return `bg-${PIECE_COLORS[val]} shadow-inner shadow-white/20`;
    }
    if (val === -1) {
      // Ghost piece
      return 'bg-slate-500/30 border border-slate-400/50';
    }
     if (val === -2) {
      // Aimer target
      return 'bg-yellow-500/70 animate-pulse border-2 border-yellow-300';
    }
    if (val === -3) {
      // Line clearing animation
      return 'animate-line-clear';
    }
    // Empty cell
    return 'bg-slate-800';
  });
}

--- END OF FILE: src/components/cell/cell.component.ts ---

--- START OF FILE: src/components/falling-piece/falling-piece.component.css ---
/* Component-specific styles for FallingPieceComponent can go here. */

--- END OF FILE: src/components/falling-piece/falling-piece.component.css ---

--- START OF FILE: src/components/falling-piece/falling-piece.component.html ---
<div 
  class="absolute grid z-20"
  [style.transition]="transitionStyle()"
  [style.left.px]="position().left"
  [style.top.px]="position().top"
  [style.grid-template-columns]="'repeat(' + (pieceShape()[0]?.length || 0) + ', ' + cellSize() + 'px)'"
  [class.opacity-40]="isGhost()">
  @for (row of pieceShape(); track $index) {
    @for (cell of row; track $index) {
      <div 
        class="aspect-square"
        [style.width.px]="cellSize()"
        [style.height.px]="cellSize()"
        [class]="getCellClass(cell)">
      </div>
    }
  }
</div>

--- END OF FILE: src/components/falling-piece/falling-piece.component.html ---

--- START OF FILE: src/components/falling-piece/falling-piece.component.ts ---
/**
 * @fileoverview Component for rendering the animated, currently falling piece.
 */
import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';
import { Piece } from '../../utils/piece.interface';
import { PIECE_COLORS } from '../../utils/constants';

/**
 * A component dedicated to rendering the currently falling piece and its ghost.
 * It is positioned absolutely over the main board and uses CSS transitions for smooth movement.
 */
@Component({
  selector: 'app-falling-piece',
  standalone: true,
  templateUrl: './falling-piece.component.html',
  styleUrls: ['./falling-piece.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class FallingPieceComponent {
  /** The piece object to be rendered. */
  piece = input.required<Piece>();
  /** Whether this piece should be rendered as a semi-transparent ghost. */
  isGhost = input<boolean>(false);
  /** The current animation mode ('step' or 'smooth'). */
  animationMode = input<'step' | 'smooth'>('smooth');
  /** The fractional progress (0-1) of the piece's drop, for smooth animation. */
  dropProgress = input<number>(0);
  /** The size of a single cell in pixels, used for dynamic scaling. */
  cellSize = input<number>(32);

  /** A computed signal for the piece's shape matrix. */
  pieceShape = computed(() => this.piece().shape);
  
  /**
   * Computes the `top` and `left` CSS properties in pixels for positioning the piece.
   * In smooth mode, it incorporates `dropProgress` for fluid vertical movement.
   */
  position = computed(() => {
    const piece = this.piece();
    const size = this.cellSize();
    // In smooth mode, add the fractional drop progress for a fluid animation.
    const yOffset = (this.animationMode() === 'smooth' && !this.isGhost()) 
      ? this.dropProgress() 
      : 0;
    
    return {
        left: piece.x * size,
        top: (piece.y + yOffset) * size,
    };
  });

  /**
   * Computes the `transition` CSS property based on the animation mode.
   * In 'smooth' mode, vertical transitions are disabled as `top` is updated per frame.
   * In 'step' mode, all transforms are transitioned.
   */
  transitionStyle = computed(() => {
    const duration = '100ms';
    const timing = 'ease-out';
    
    // The ghost piece should always have a quick transition for all movements.
    if (this.isGhost()) {
      return `all ${duration} ${timing}`;
    }

    // In smooth mode, `top` is updated every frame, so we only transition horizontal movement.
    if (this.animationMode() === 'smooth') {
      return `left ${duration} ${timing}`;
    }

    // In step mode, we transition all movements for a classic, snappy feel.
    return `all ${duration} ${timing}`;
  });

  /** Private reference to the color map. */
  private colors = PIECE_COLORS;
  
  /**
   * Gets the appropriate CSS classes for a single cell within the falling piece.
   * @param cellValue The numeric value of the cell from the piece's shape matrix.
   * @returns A string of Tailwind CSS classes.
   */
  getCellClass(cellValue: number): string {
    if (cellValue <= 0) {
      return 'bg-transparent';
    }
    if (this.isGhost()) {
      return 'bg-slate-500/30 border border-slate-400/50';
    }
    return `bg-${this.colors[cellValue]} shadow-inner shadow-white/20 border border-slate-700/50`;
  }
}

--- END OF FILE: src/components/falling-piece/falling-piece.component.ts ---

--- START OF FILE: src/components/game-overlay/game-overlay.component.css ---
/* Component-specific styles for GameOverlayComponent can go here. */

--- END OF FILE: src/components/game-overlay/game-overlay.component.css ---

--- START OF FILE: src/components/game-overlay/game-overlay.component.html ---
 @if (gameState() === 'start' || gameState() === 'paused' || gameState() === 'gameover' || gameState() === 'countdown') {
  <div class="absolute inset-0 bg-black/70 flex flex-col justify-center items-center text-center backdrop-blur-sm z-30 p-4">
    @switch (gameState()) {
      @case ('start') {
        <h2 class="text-3xl font-bold text-cyan-400 mb-4">Welcome!</h2>
        <button (click)="start.emit()" class="px-6 py-3 bg-green-600 hover:bg-green-500 rounded-md text-xl animate-pulse">Start Game</button>
         <div class="mt-8 text-left text-sm max-w-xs">
            <h3 class="text-lg text-cyan-400 mb-2 text-center uppercase tracking-widest">Controls</h3>
            <ul class="text-xs space-y-1 text-slate-300">
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Arrows:</span> Move</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Up:</span> Rotate</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Space:</span> Hard Drop</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">C:</span> Hold</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">P:</span> Pause</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">1-4:</span> Power-ups</li>
           </ul>
        </div>
      }
      @case ('paused') {
        <h2 class="text-3xl font-bold text-yellow-400 mb-6">Paused</h2>
        <div class="flex flex-col gap-4 w-full max-w-[220px] mb-6">
            <button (click)="togglePause.emit()" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-md text-base w-full">Resume</button>
            <button (click)="restart.emit()" class="px-4 py-2 border-2 border-green-500 text-green-500 hover:bg-green-500/20 transition-colors rounded-md text-base w-full">Restart</button>
            <button (click)="toggleAnimation.emit()" class="px-4 py-2 border-2 border-cyan-500 text-cyan-500 hover:bg-cyan-500/20 transition-colors rounded-md text-xs w-full capitalize">
                Animation: {{ animationMode() }}
            </button>
        </div>
         <div class="text-left text-sm max-w-xs">
            <h3 class="text-lg text-cyan-400 mb-2 text-center uppercase tracking-widest">Controls</h3>
            <ul class="text-xs space-y-1 text-slate-300">
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Arrows:</span> Move</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Up:</span> Rotate</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Space:</span> Hard Drop</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">C:</span> Hold</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">P:</span> Pause</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">1-4:</span> Power-ups</li>
           </ul>
        </div>
      }
      @case ('gameover') {
        <h2 class="text-3xl font-bold text-red-500 mb-4">Game Over</h2>
        <button (click)="restart.emit()" class="px-6 py-3 bg-green-600 hover:bg-green-500 rounded-md text-xl">Play Again</button>
      }
      @case ('countdown') {
        <div class="text-8xl font-bold text-white animate-pulse">{{ countdownValue() }}</div>
      }
    }
  </div>
}
--- END OF FILE: src/components/game-overlay/game-overlay.component.html ---

--- START OF FILE: src/components/game-overlay/game-overlay.component.ts ---
/**
 * @fileoverview Component for displaying overlay screens like "Start", "Paused", and "Game Over".
 */
import { ChangeDetectionStrategy, Component, input, output } from '@angular/core';

/**
 * A UI component that displays contextual overlays based on the current game state.
 * It provides buttons for the player to interact with the game state (e.g., start, pause, restart).
 */
@Component({
  selector: 'app-game-overlay',
  standalone: true,
  templateUrl: './game-overlay.component.html',
  styleUrls: ['./game-overlay.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class GameOverlayComponent {
  /** The current state of the game, which determines which overlay to show. */
  gameState = input.required<'start' | 'playing' | 'paused' | 'gameover' | 'countdown' | 'clearing'>();
  
  /** The remaining seconds for the start-of-game countdown. */
  countdownValue = input<number>(0);

  /** The current animation mode, displayed in the pause menu. */
  animationMode = input<'step' | 'smooth'>('smooth');

  /** Emits when the "Start Game" button is clicked. */
  start = output<void>();
  
  /** Emits when a "Restart" or "Play Again" button is clicked. */
  restart = output<void>();

  /** Emits when the "Resume" button is clicked. */
  togglePause = output<void>();

  /** Emits when the animation mode toggle button is clicked. */
  toggleAnimation = output<void>();
}

--- END OF FILE: src/components/game-overlay/game-overlay.component.ts ---

--- START OF FILE: src/components/info-panel/info-panel.component.css ---
/* Component-specific styles for InfoPanelComponent can go here. */

--- END OF FILE: src/components/info-panel/info-panel.component.css ---

--- START OF FILE: src/components/info-panel/info-panel.component.html ---
<div class="bg-slate-800/80 p-2 md:p-3 lg:p-4 rounded-lg border-2 border-slate-700 shadow-lg shadow-cyan-500/10 h-full">
  @if (title()) {
    <h3 class="text-[11px] sm:text-xs font-bold text-cyan-400 uppercase mb-2 tracking-normal md:tracking-widest text-center">{{ title() }}</h3>
  }
  <ng-content></ng-content>
</div>
--- END OF FILE: src/components/info-panel/info-panel.component.html ---

--- START OF FILE: src/components/info-panel/info-panel.component.ts ---
/**
 * @fileoverview A reusable panel component for displaying game information.
 */
import { ChangeDetectionStrategy, Component, input } from '@angular/core';

/**
 * A generic, styled container component with a title. It is used to display
 * various pieces of game information like score, next piece, etc., using content projection.
 */
@Component({
  selector: 'app-info-panel',
  standalone: true,
  templateUrl: './info-panel.component.html',
  styleUrls: ['./info-panel.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class InfoPanelComponent {
  /** The title to be displayed at the top of the panel. */
  title = input<string | undefined>();
}
--- END OF FILE: src/components/info-panel/info-panel.component.ts ---

--- START OF FILE: src/components/piece-preview/piece-preview.component.css ---
/* Component-specific styles for PiecePreviewComponent can go here. */

--- END OF FILE: src/components/piece-preview/piece-preview.component.css ---

--- START OF FILE: src/components/piece-preview/piece-preview.component.html ---
<div class="grid" [style.grid-template-columns]="'repeat(' + piece()[0].length + ', 1fr)'">
  @for (row of piece(); track $index) {
    @for (cell of row; track $index) {
      <div 
        class="aspect-square w-4 h-4"
        [class]="cell > 0 ? 'bg-' + colors[cell] : 'bg-transparent'">
      </div>
    }
  }
</div>
--- END OF FILE: src/components/piece-preview/piece-preview.component.html ---

--- START OF FILE: src/components/piece-preview/piece-preview.component.ts ---
/**
 * @fileoverview Component for displaying a small preview of a Tetris piece.
 */
import { ChangeDetectionStrategy, Component, input } from '@angular/core';
import { PIECE_COLORS } from '../../utils/constants';

/**
 * Renders a small, static preview of a given piece shape.
 * Used for the "Next" and "Hold" displays.
 */
@Component({
  selector: 'app-piece-preview',
  standalone: true,
  templateUrl: './piece-preview.component.html',
  styleUrls: ['./piece-preview.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PiecePreviewComponent {
  /** The 2D array representing the shape of the piece to be displayed. */
  piece = input.required<number[][]>();
  
  /** A map of color indices to Tailwind CSS color names. */
  colors = PIECE_COLORS;
}

--- END OF FILE: src/components/piece-preview/piece-preview.component.ts ---

--- START OF FILE: src/services/README.md ---
# Arquitectura de Servicios - Tetros

## Flujo de Datos
Usuario (Teclado/Touch)
â†“
InputService
â†“
GameActionsService â†â†’ BoardService
â†“              â†“
GameStateService â† AnimationService
â†‘
GameLoopService â†’ GameActionsService
â†‘
PowerUpService

## Responsabilidades

### GameStateService
- Single source of truth para todo el estado del juego
- Solo contiene signals, sin lÃ³gica de negocio
- No tiene dependencias con otros servicios

### BoardService
- Operaciones sobre el tablero (clear lines, apply gravity)
- Lee y modifica el estado a travÃ©s de GameStateService

### AnimationService
- CÃ¡lculo del ghost piece
- Control de modos de animaciÃ³n (smooth/step)
- CÃ¡lculo de posiciones visuales

### GameActionsService
- LÃ³gica core del juego (mover, rotar, lock piece)
- Orquesta cambios entre Board y State
- Valida movimientos

### GameLoopService
- Motor temporal con requestAnimationFrame
- Controla velocidad de caÃ­da segÃºn nivel
- Maneja el drop automÃ¡tico

### InputService
- TraducciÃ³n de teclas a acciones
- ImplementaciÃ³n de DAS/ARR
- No conoce reglas del juego

### PowerUpService
- Sistema modular de power-ups
- Cada power-up como estrategia independiente

### GameFacade
- Orquestador principal
- Expone API pÃºblica para componentes
- Maneja inicio/pausa/reinicio del juego

## Testing

Para testear un servicio individual:
1. Mock sus dependencias
2. Test de estado inicial
3. Test de cada mÃ©todo pÃºblico
4. Test de edge cases

## Agregar Nuevas Features

Para agregar un nuevo power-up:
1. AÃ±adir tipo en GameStateService
2. Implementar lÃ³gica en PowerUpService
3. Mapear tecla en InputService (opcional)

--- END OF FILE: src/services/README.md ---

--- START OF FILE: src/services/animation.service.ts ---
import { Injectable, computed, inject } from '@angular/core';
import { GameStateService } from './game-state.service';
import { isValidPosition } from '../utils/game-logic.utils';

@Injectable({
  providedIn: 'root'
})
export class AnimationService {
  private state = inject(GameStateService);

  /**
   * A computed signal that calculates the position of the ghost piece.
   * The ghost piece shows where the current piece will land.
   */
  ghostPiece = computed(() => {
    const piece = this.state.currentPiece();
    const board = this.state.board();

    // Do not show ghost piece if game is not in a playable state.
    if (!piece || this.state.gameState() !== 'playing') {
      return null;
    }

    // Create a copy of the piece to mutate.
    let ghost = { ...piece, shape: piece.shape.map(row => [...row]) };

    // Drop the ghost piece down until it hits something.
    while (isValidPosition(ghost, board)) {
      ghost.y++;
    }

    // Move it back up one step to its final valid position.
    ghost.y--;

    return ghost;
  });

  /**
   * Toggles the animation mode between 'smooth' and 'step' in the game state.
   */
  toggleAnimationMode(): void {
    this.state.animationMode.update(current => current === 'smooth' ? 'step' : 'smooth');
  }
}

--- END OF FILE: src/services/animation.service.ts ---

--- START OF FILE: src/services/board.service.ts ---
import { Injectable, inject } from '@angular/core';
import { GameStateService } from './game-state.service';
import { clearLines } from '../utils/game-logic.utils';
import { Piece } from '../utils/piece.interface';
import { applyGravityToColumn } from '../utils/board.utils';
import { COLS } from '../utils/constants';

@Injectable({
  providedIn: 'root'
})
export class BoardService {
  private state = inject(GameStateService);

  /**
   * Creates a new board matrix with a piece permanently added.
   * @param piece The piece to add.
   * @param board The board to add the piece to.
   * @returns A new 2D array representing the board.
   */
  getBoardWithPiece(piece: Piece, board: number[][]): number[][] {
    const newBoard = board.map(row => [...row]);
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value > 0) {
          const boardX = piece.x + x;
          const boardY = piece.y + y;
          if (boardY >= 0) {
            newBoard[boardY][boardX] = value;
          }
        }
      });
    });
    return newBoard;
  }

  /**
   * Processes a board, clearing any completed lines. It relies on a utility function
   * to perform the actual clearing.
   * @param board The board to process.
   * @returns An object containing the new board and the number of lines cleared.
   */
  clearCompletedLines(board: number[][]): { boardAfterClear: number[][], linesCleared: number } {
    const { boardAfterClear, lines } = clearLines(board);
    return { boardAfterClear, linesCleared: lines };
  }

  /**
   * Applies gravity to a single column of the current board state and updates the board.
   * Used by the 'aimer' power-up.
   * @param columnIndex The index of the column to apply gravity to.
   */
  applyGravityToColumn(columnIndex: number): void {
    this.state.board.update(board => {
        const newBoard = board.map(row => [...row]);
        applyGravityToColumn(newBoard, columnIndex);
        return newBoard;
    });
  }

  /**
   * Clears a specific row on the board. Used by the 'laser' power-up.
   * @param rowIndex The index of the row to clear.
   */
  clearRow(rowIndex: number): void {
    this.state.board.update(board => {
        const newBoard = board.map(row => [...row]);
        if (newBoard[rowIndex]) {
            newBoard[rowIndex] = new Array(COLS).fill(0);
        }
        return newBoard;
    });
  }
}

--- END OF FILE: src/services/board.service.ts ---

--- START OF FILE: src/services/game-actions.service.spec.ts ---
import { TestBed } from '@angular/core/testing';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { GameActionsService } from './game-actions.service';
import { GameStateService } from './game-state.service';
import { BoardService } from './board.service';
import { AnimationService } from './animation.service';
import { Piece } from '../utils/piece.interface';
import { createEmptyBoard } from '../utils/board.utils';
import * as gameLogicUtils from '../utils/game-logic.utils';
import { signal } from '@angular/core';

vi.mock('../utils/game-logic.utils', async (importOriginal) => {
  const actual = await importOriginal<typeof gameLogicUtils>();
  return {
    ...actual, // Keep other functions from the module
    isValidPosition: vi.fn(), // Mock isValidPosition specifically
  };
});

describe('GameActionsService', () => {
  let actionsService: GameActionsService;
  let mockStateService: GameStateService;
  let mockBoardService: Partial<BoardService>;
  let mockAnimationService: Partial<AnimationService>;

  // Mock signals for state
  const mockCurrentPiece = signal<Piece | null>(null);
  const mockBoard = signal(createEmptyBoard());

  beforeEach(() => {
    // Reset mocks before each test
    vi.mocked(gameLogicUtils.isValidPosition).mockClear();

    // Define mock implementations for the services
    mockStateService = {
      currentPiece: mockCurrentPiece,
      board: mockBoard,
      // Add any other properties from GameStateService that are used
    } as GameStateService;

    mockBoardService = {
      // Mock methods used by GameActionsService if any
    };

    mockAnimationService = {
      // Mock methods used by GameStateService if any
    };

    // Configure the test bed
    TestBed.configureTestingModule({
      providers: [
        GameActionsService,
        { provide: GameStateService, useValue: mockStateService },
        { provide: BoardService, useValue: mockBoardService },
        { provide: AnimationService, useValue: mockAnimationService },
      ],
    });

    // Get the service instance from the TestBed injector
    actionsService = TestBed.inject(GameActionsService);

    // Reset signals before each test
    mockCurrentPiece.set(null);
    mockBoard.set(createEmptyBoard());
  });

  it('should rotate the current piece successfully if the rotation is valid', () => {
    // 1. Arrange
    // For this test, we need isValidPosition to return true
    vi.mocked(gameLogicUtils.isValidPosition).mockReturnValue(true);

    const initialPiece: Piece = {
      x: 3,
      y: 4,
      shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], // T-shape
    };
    // Set the initial state in our mock service
    mockCurrentPiece.set(initialPiece);
    mockBoard.set(createEmptyBoard());

    // This is the correct clockwise rotation of the T-piece
    const rotatedShape = [[0, 1, 0], [0, 1, 1], [0, 1, 0]];

    // 2. Act
    actionsService.rotate();

    // 3. Assert
    const finalPiece = mockCurrentPiece();
    expect(finalPiece).not.toBeNull();
    expect(finalPiece!.shape).toEqual(rotatedShape);
    // Position should be the same as no wall kick was needed
    expect(finalPiece!.x).toBe(3);
    expect(finalPiece!.y).toBe(4);
  });

  it('should not rotate the piece if isValidPosition always returns false', () => {
    // 1. Arrange
    const initialPiece: Piece = {
      x: 1,
      y: 1,
      shape: [[0, 6, 0], [6, 6, 6], [0, 0, 0]], // T-piece
    };
    mockCurrentPiece.set(initialPiece);
    mockBoard.set(createEmptyBoard());

    // Force isValidPosition to always return false
    vi.mocked(gameLogicUtils.isValidPosition).mockReturnValue(false);

    // 2. Act
    actionsService.rotate();

    // 3. Assert
    const finalPiece = mockCurrentPiece();
    // The piece should not have changed because no valid rotation was found
    expect(finalPiece!.shape).toEqual(initialPiece.shape);
    expect(finalPiece!.x).toBe(initialPiece.x);
    // Ensure the mock was actually called
    expect(gameLogicUtils.isValidPosition).toHaveBeenCalled();
  });
});

--- END OF FILE: src/services/game-actions.service.spec.ts ---

--- START OF FILE: src/services/game-actions.service.ts ---
import { Injectable, inject } from '@angular/core';
import { GameStateService } from './game-state.service';
import { BoardService } from './board.service';
import { AnimationService } from './animation.service';
import { Piece } from '../utils/piece.interface';
import { getRandomPiece, rotate } from '../utils/piece.utils';
import { isValidPosition, calculateScore } from '../utils/game-logic.utils';
import { LEVEL_THRESHOLD, COLS, LINE_CLEAR_ANIMATION_DURATION } from '../utils/constants';

@Injectable({
  providedIn: 'root'
})
export class GameActionsService {
  private state = inject(GameStateService);
  private boardService = inject(BoardService);
  private animationService = inject(AnimationService);

  /**
   * The main tick of the game, attempting to move the piece down.
   * If the piece cannot move down, it gets locked.
   * This is intended to be called by the GameLoopService.
   */
  tick(): void {
    if (!this.movePiece(0, 1)) {
      this.lockPiece();
    }
  }

  // --- Player Actions ---

  moveLeft(): void {
    this.movePiece(-1, 0);
  }

  moveRight(): void {
    this.movePiece(1, 0);
  }

  softDrop(): void {
    this.tick();
    // The drop counter reset will be handled by the game loop service
    // to avoid a dependency from Actions -> Loop.
    this.state.dropProgress.set(0);
  }

  hardDrop(): void {
    const piece = this.state.currentPiece();
    const ghost = this.animationService.ghostPiece();
    if (piece && ghost) {
      this.state.currentPiece.set({ ...piece, y: ghost.y });
      this.lockPiece();
    }
  }

  rotate(): void {
    const piece = this.state.currentPiece();
    if (!piece) return;

    const rotatedPiece = rotate(piece);
    const kicks = [
      { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 0 },
      { x: 2, y: 0 }, { x: -2, y: 0 }, { x: 0, y: -1 }
    ];

    for (const kick of kicks) {
      const kickedPiece = {
        ...rotatedPiece,
        x: rotatedPiece.x + kick.x,
        y: rotatedPiece.y + kick.y
      };
      if (isValidPosition(kickedPiece, this.state.board())) {
        this.state.currentPiece.set(kickedPiece);
        return;
      }
    }
  }

  hold(): void {
    if (!this.state.isHoldingAllowed() || this.state.gameState() !== 'playing') return;

    const current = this.state.currentPiece();
    const held = this.state.holdPiece();

    this.state.holdPiece.set({ ...current!, x: 3, y: 0 });
    if (held) {
      this.state.currentPiece.set({ ...held, x: 3, y: 0 });
    } else {
      this.spawnNewPiece();
    }
    this.state.isHoldingAllowed.set(false);
  }

  // --- Internal Game Logic ---

  private movePiece(dx: number, dy: number): boolean {
    const piece = this.state.currentPiece();
    if (!piece) return false;

    const newPiece = { ...piece, x: piece.x + dx, y: piece.y + dy };
    if (isValidPosition(newPiece, this.state.board())) {
      this.state.currentPiece.set(newPiece);
      return true;
    }
    return false;
  }

  private lockPiece(): void {
    const piece = this.state.currentPiece();
    if (!piece) return;

    const boardWithPiece = this.boardService.getBoardWithPiece(piece, this.state.board());

    const linesToClear: number[] = [];
    boardWithPiece.forEach((row, y) => {
        if (row.every(cell => cell > 0)) {
            linesToClear.push(y);
        }
    });

    if (linesToClear.length > 0) {
      this.state.gameState.set('clearing');
      this.state.currentPiece.set(null);

      const animationBoard = boardWithPiece.map((row, y) => {
        if (linesToClear.includes(y)) {
          return Array(COLS).fill(-3); // Use special value for clearing animation
        }
        return row;
      });
      this.state.board.set(animationBoard);

      setTimeout(() => {
        const { boardAfterClear, linesCleared } = this.boardService.clearCompletedLines(boardWithPiece);
        this.state.board.set(boardAfterClear);

        this.state.score.update(s => s + calculateScore(linesCleared, this.state.level()));
        this.state.linesCleared.update(l => l + linesCleared);
        this.state.level.set(Math.floor(this.state.linesCleared() / LEVEL_THRESHOLD) + 1);
        this.state.powerUps.update(p => ({ laser: p.laser + 1, slow: p.slow + 1, mutate: p.mutate + 1, aimer: p.aimer + 1 }));

        this.spawnNewPiece();
        this.state.isHoldingAllowed.set(true);
        this.state.gameState.set('playing');
      }, LINE_CLEAR_ANIMATION_DURATION);
    } else {
      this.state.board.set(boardWithPiece);
      this.spawnNewPiece();
      this.state.isHoldingAllowed.set(true);
    }
  }

  private spawnNewPiece(): void {
    this.state.dropProgress.set(0);
    this.state.currentPiece.set(this.state.nextPiece());
    this.state.nextPiece.set(getRandomPiece());

    if (!isValidPosition(this.state.currentPiece()!, this.state.board())) {
      this.state.gameState.set('gameover');
    }
  }

  /**
   * Checks if the current piece can move down.
   * Public so other services (like GameLoop) can use it for calculations.
   */
  public canMoveDown(): boolean {
    const piece = this.state.currentPiece();
    if (!piece) return false;
    const newPiece = { ...piece, y: piece.y + 1 };
    return isValidPosition(newPiece, this.state.board());
  }
}

--- END OF FILE: src/services/game-actions.service.ts ---

--- START OF FILE: src/services/game-loop.service.ts ---
import { Injectable, inject, effect } from '@angular/core';
import { GameStateService } from './game-state.service';
import { GameActionsService } from './game-actions.service';

@Injectable({
  providedIn: 'root'
})
export class GameLoopService {
  private state = inject(GameStateService);
  private actions = inject(GameActionsService);

  private lastTime = 0;
  private dropCounter = 0;
  private frameId: number | null = null;

  constructor() {
    // Este effect observa el signal softDropActive para resetear el contador
    // cuando el usuario inicia un soft drop manual, evitando drops dobles
    // al sincronizar el drop manual con el automÃ¡tico del game loop
    effect(() => {
      if (this.state.softDropActive()) {
        this.resetCounter();
      }
    });
  }

  start(): void {
    if (this.frameId) return;
    // Don't reset time here, let the caller decide.
    this.frameId = requestAnimationFrame((time) => this.loop(time));
  }

  stop(): void {
    if (this.frameId) {
      cancelAnimationFrame(this.frameId);
    }
    this.frameId = null;
  }

  resetTime(): void {
    this.lastTime = 0;
  }

  private resetCounter(): void {
    this.dropCounter = 0;
  }

  private loop(time: number): void {
    if (this.state.gameState() !== 'playing') {
      this.stop();
      return;
    }

    if (this.lastTime === 0) {
      this.lastTime = time;
    }
    const deltaTime = time - this.lastTime;
    this.lastTime = time;
    this.dropCounter += deltaTime;

    const dropInterval = (1000 / this.state.level()) * (this.state.slowMotionActive() ? 3 : 1);

    if (!this.state.softDropActive()) {
      while (this.dropCounter >= dropInterval) {
        this.actions.tick();
        if (this.state.gameState() !== 'playing') {
          this.state.dropProgress.set(0);
          this.stop();
          return;
        }
        this.dropCounter -= dropInterval;
      }
    }

    if (this.state.currentPiece()) {
      if (this.actions.canMoveDown()) {
        this.state.dropProgress.set(Math.min(1, this.dropCounter / dropInterval));
      } else {
        this.state.dropProgress.set(0);
      }
    } else {
      this.state.dropProgress.set(0);
    }

    this.frameId = requestAnimationFrame((t) => this.loop(t));
  }
}

--- END OF FILE: src/services/game-loop.service.ts ---

--- START OF FILE: src/services/game-state.service.ts ---
import { Injectable, signal } from '@angular/core';
import { createEmptyBoard } from '../utils/board.utils';
import { Piece } from '../utils/piece.interface';
import { COLS, ROWS } from '../utils/constants';

// Type Definitions
export type GameState = 'start' | 'playing' | 'paused' | 'gameover' | 'countdown' | 'clearing';
export type PowerUp = 'laser' | 'slow' | 'mutate' | 'aimer';
export type AnimationMode = 'step' | 'smooth';

@Injectable({
  providedIn: 'root'
})
export class GameStateService {
  // --- Game State Signals ---
  board = signal(createEmptyBoard());
  currentPiece = signal<Piece | null>(null);
  nextPiece = signal<Piece | null>(null);
  holdPiece = signal<Piece | null>(null);
  gameState = signal<GameState>('start');
  score = signal(0);
  level = signal(1);
  linesCleared = signal(0);
  isHoldingAllowed = signal(true);
  /** Flag to indicate if the user is actively holding the soft drop key. */
  softDropActive = signal(false);
  countdownValue = signal(0);

  // --- Animation Signals ---
  animationMode = signal<AnimationMode>('smooth');
  dropProgress = signal(0);

  // --- Power-Up Signals ---
  powerUps = signal<{[key in PowerUp]: number}>({ laser: 1, slow: 1, mutate: 1, aimer: 1 });
  isAiming = signal(false);
  aimerPosition = signal({ x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2) });
  slowMotionActive = signal(false);

  constructor() { }
}

--- END OF FILE: src/services/game-state.service.ts ---

--- START OF FILE: src/services/game.facade.ts ---
import { Injectable, inject } from '@angular/core';
import { GameStateService, PowerUp } from './game-state.service';
import { GameActionsService } from './game-actions.service';
import { GameLoopService } from './game-loop.service';
import { InputService } from './input.service';
import { PowerUpService } from './power-up.service';
import { AnimationService } from './animation.service';
import { createEmptyBoard } from '../utils/board.utils';
import { getRandomPiece } from '../utils/piece.utils';
import { COLS, ROWS } from '../utils/constants';

@Injectable({
  providedIn: 'root'
})
export class GameFacade {
  private state = inject(GameStateService);
  private actions = inject(GameActionsService);
  private loop = inject(GameLoopService);
  private input = inject(InputService);
  private powerUpService = inject(PowerUpService);
  private animation = inject(AnimationService);

  private countdownIntervalId: any = null;

  // --- State Signals (exposed as readonly) ---
  readonly board = this.state.board.asReadonly();
  readonly currentPiece = this.state.currentPiece.asReadonly();
  readonly nextPiece = this.state.nextPiece.asReadonly();
  readonly holdPiece = this.state.holdPiece.asReadonly();
  readonly gameState = this.state.gameState.asReadonly();
  readonly score = this.state.score.asReadonly();
  readonly level = this.state.level.asReadonly();
  readonly linesCleared = this.state.linesCleared.asReadonly();
  readonly countdownValue = this.state.countdownValue.asReadonly();
  readonly powerUps = this.state.powerUps.asReadonly();
  readonly isAiming = this.state.isAiming.asReadonly();
  readonly dropProgress = this.state.dropProgress.asReadonly();
  readonly animationMode = this.state.animationMode.asReadonly();
  readonly ghostPiece = this.animation.ghostPiece;

  // --- Action Methods (for touch controls) ---
  readonly moveLeft = this.actions.moveLeft.bind(this.actions);
  readonly moveRight = this.actions.moveRight.bind(this.actions);
  readonly softDrop = this.actions.softDrop.bind(this.actions);
  readonly hardDrop = this.actions.hardDrop.bind(this.actions);
  readonly rotate = this.actions.rotate.bind(this.actions);
  readonly hold = this.actions.hold.bind(this.actions);

  // --- Input Methods (for keyboard controls) ---
  pressKey(key: string): void {
    if (this.state.isAiming()) {
      this.powerUpService.handleAimerKeys(key);

      if (key === 'Enter') {
        this.loop.resetTime();
        this.loop.start();
      }
    } else {
      this.input.press(key);
    }
  }
  releaseKey(key: string) { this.input.release(key); }

  // --- PowerUp Methods ---
  activatePowerUp(powerUp: PowerUp) { this.powerUpService.activatePowerUp(powerUp); }
  canUsePowerUp = this.powerUpService.canUsePowerUp.bind(this.powerUpService);

  // --- Animation Methods ---
  toggleAnimationMode() { this.animation.toggleAnimationMode(); }

  // --- Orchestration Methods ---
  startGame(): void {
    if (this.countdownIntervalId) {
      clearInterval(this.countdownIntervalId);
    }
    this.input.clearTimers();
    this.powerUpService.reset();

    // Reset all state
    this.state.board.set(createEmptyBoard());
    this.state.currentPiece.set(getRandomPiece());
    this.state.nextPiece.set(getRandomPiece());
    this.state.holdPiece.set(null);
    this.state.score.set(0);
    this.state.level.set(1);
    this.state.linesCleared.set(0);
    this.state.isHoldingAllowed.set(true);
    this.state.powerUps.set({ laser: 1, slow: 1, mutate: 1, aimer: 1 });
    this.state.isAiming.set(false);
    this.state.aimerPosition.set({ x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2) });
    this.state.dropProgress.set(0);

    this.state.gameState.set('countdown');
    this.state.countdownValue.set(3);

    this.countdownIntervalId = setInterval(() => {
      this.state.countdownValue.update(v => v - 1);
      if (this.state.countdownValue() <= 0) {
        clearInterval(this.countdownIntervalId);
        this.countdownIntervalId = null;
        this.state.gameState.set('playing');
        this.loop.resetTime();
        this.loop.start();
      }
    }, 1000);
  }

  togglePause(): void {
    if (this.state.gameState() === 'playing') {
      this.state.gameState.set('paused');
      this.loop.stop();
      this.input.clearTimers();
    } else if (this.state.gameState() === 'paused') {
      this.state.gameState.set('playing');
      this.loop.resetTime(); // Prevent sudden drop after unpausing
      this.loop.start();
    }
  }
}

--- END OF FILE: src/services/game.facade.ts ---

--- START OF FILE: src/services/input.service.ts ---
import { Injectable, inject } from '@angular/core';
import { GameActionsService } from './game-actions.service';
import { PowerUpService } from './power-up.service';
import { GameStateService } from './game-state.service';
import { DAS_DELAY, ARR_INTERVAL } from '../utils/constants';

@Injectable({
  providedIn: 'root'
})
export class InputService {
  private actions = inject(GameActionsService);
  private powerUps = inject(PowerUpService);
  private state = inject(GameStateService);

  // Timers for Delayed Auto-Shift (DAS) and Auto-Repeat Rate (ARR)
  private dasTimer: any = null;
  private arrTimer: any = null;
  private softDropInterval: any = null;

  /**
   * Handles a key press event.
   * @param key The key identifier from a KeyboardEvent.
   */
  press(key: string): void {
    if (this.state.isAiming()) {
      this.powerUps.handleAimerKeys(key);
      return;
    }
    if (this.state.gameState() !== 'playing') return;

    switch (key) {
      case 'ArrowLeft':
      case 'ArrowRight':
        if (this.dasTimer || this.arrTimer) return;
        const move = () => key === 'ArrowLeft' ? this.actions.moveLeft() : this.actions.moveRight();
        move();
        this.dasTimer = setTimeout(() => {
          this.arrTimer = setInterval(move, ARR_INTERVAL);
        }, DAS_DELAY);
        break;
      case 'ArrowDown':
        if (this.softDropInterval) return;
        this.state.softDropActive.set(true);
        this.actions.softDrop();
        this.softDropInterval = setInterval(() => {
            this.actions.softDrop();
        }, ARR_INTERVAL);
        break;
      case 'ArrowUp':
        this.actions.rotate();
        break;
      case ' ': // Spacebar
        this.actions.hardDrop();
        break;
      case 'c':
      case 'C':
        this.actions.hold();
        break;
      case '1': this.powerUps.activatePowerUp('laser'); break;
      case '2': this.powerUps.activatePowerUp('slow'); break;
      case '3': this.powerUps.activatePowerUp('mutate'); break;
      case '4': this.powerUps.activatePowerUp('aimer'); break;
    }
  }

  /**
   * Handles a key release event.
   * @param key The key identifier from a KeyboardEvent.
   */
  release(key: string): void {
    switch (key) {
      case 'ArrowLeft':
      case 'ArrowRight':
        clearTimeout(this.dasTimer);
        clearInterval(this.arrTimer);
        this.dasTimer = null;
        this.arrTimer = null;
        break;
      case 'ArrowDown':
        clearInterval(this.softDropInterval);
        this.softDropInterval = null;
        this.state.softDropActive.set(false);
        break;
    }
  }

  /**
   * Clears all active movement timers. Useful when the game is paused or reset.
   */
  clearTimers(): void {
    clearTimeout(this.dasTimer);
    clearInterval(this.arrTimer);
    clearInterval(this.softDropInterval);
    this.dasTimer = null;
    this.arrTimer = null;
    this.softDropInterval = null;
    if(this.state.softDropActive()) {
        this.state.softDropActive.set(false);
    }
  }
}

--- END OF FILE: src/services/input.service.ts ---

--- START OF FILE: src/services/power-up.service.ts ---
import { Injectable, inject } from '@angular/core';
import { GameStateService, PowerUp } from './game-state.service';
import { BoardService } from './board.service';
import { getRandomPiece } from '../utils/piece.utils';
import { ROWS, COLS, SLOW_POWERUP_DURATION } from '../utils/constants';

@Injectable({
  providedIn: 'root'
})
export class PowerUpService {
  private state = inject(GameStateService);
  private boardService = inject(BoardService);

  /** Resets the internal state of the service. */
  reset(): void {
    this.state.slowMotionActive.set(false);
  }

  canUsePowerUp(powerUp: PowerUp): boolean {
    return this.state.powerUps()[powerUp] > 0 && this.state.gameState() === 'playing' && !this.state.isAiming();
  }

  activatePowerUp(powerUp: PowerUp): void {
    if (!this.canUsePowerUp(powerUp)) return;

    this.state.powerUps.update(p => ({...p, [powerUp]: p[powerUp] - 1}));

    switch(powerUp) {
      case 'laser':
        const piece = this.state.currentPiece();
        if (!piece) return;
        // Find the lowest occupied row of the piece for more accurate targeting
        let bottomRow = piece.y;
        for (let row = piece.shape.length - 1; row >= 0; row--) {
          if (piece.shape[row].some(cell => cell > 0)) {
            bottomRow = piece.y + row;
            break;
          }
        }
        const y = Math.min(ROWS - 1, bottomRow + 1); // +1 to destroy the row just below the piece
        this.boardService.clearRow(y);
        break;
      case 'slow':
        this.state.slowMotionActive.set(true);
        setTimeout(() => this.state.slowMotionActive.set(false), SLOW_POWERUP_DURATION);
        break;
      case 'mutate':
        this.state.currentPiece.set(getRandomPiece());
        this.state.nextPiece.set(getRandomPiece());
        break;
      case 'aimer':
        this.state.isAiming.set(true);
        this.state.gameState.set('paused');
        this.updateAimerBoard();
        break;
    }
  }

  handleAimerKeys(key: string): void {
    if (!this.state.isAiming()) return;

    if (key === 'Enter') {
      this.executeAimer();
      return;
    }

    this.state.aimerPosition.update(pos => {
      let { x, y } = pos;
      if (key === 'ArrowLeft') x = Math.max(0, x - 1);
      if (key === 'ArrowRight') x = Math.min(COLS - 1, x + 1);
      if (key === 'ArrowUp') y = Math.max(0, y - 1);
      if (key === 'ArrowDown') y = Math.min(ROWS - 1, y + 1);
      return { x, y };
    });
    this.updateAimerBoard();
  }

  private updateAimerBoard(): void {
    const { x, y } = this.state.aimerPosition();
    this.state.board.update(b => {
      const newBoard = b.map(row => row.map(cell => cell === -2 ? 0 : cell));
      if (newBoard[y] && newBoard[y][x] !== undefined) {
        newBoard[y][x] = -2;
      }
      return newBoard;
    });
  }

  private executeAimer(): void {
    this.state.isAiming.set(false);
    const { x, y } = this.state.aimerPosition();

    // First, clean the visual marker and destroy the target cell
    this.state.board.update(b => {
      const newBoard = b.map(row => row.map(cell => cell === -2 ? 0 : cell));
      if (newBoard[y] && newBoard[y][x] !== undefined) {
        newBoard[y][x] = 0; // Destroy the target cell
      }
      return newBoard;
    });

    // Then apply gravity to the column
    this.boardService.applyGravityToColumn(x);

    this.state.gameState.set('playing');
  }
}

--- END OF FILE: src/services/power-up.service.ts ---

--- START OF FILE: src/test-setup.ts ---
import 'zone.js';
import 'zone.js/testing';
import { getTestBed } from '@angular/core/testing';
import {
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting,
} from '@angular/platform-browser-dynamic/testing';

// First, initialize the Angular testing environment.
getTestBed().initTestEnvironment(
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting(),
);

--- END OF FILE: src/test-setup.ts ---

--- START OF FILE: src/utils/board.utils.ts ---
/**
 * @fileoverview Utility functions related to the game board.
 */

import { COLS, ROWS } from './constants';

/**
 * Creates a new, empty game board matrix filled with zeros.
 * @returns A 2D number array representing the empty board.
 */
export function createEmptyBoard(): number[][] {
  return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
}

/**
 * Applies gravity to a single column after a cell has been removed.
 * This function mutates the board directly.
 * @param board The game board matrix to modify.
 * @param colIndex The index of the column to apply gravity to.
 */
export function applyGravityToColumn(board: number[][], colIndex: number): void {
    let emptyRow = -1;
    // Find the first empty cell from the bottom
    for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r][colIndex] === 0) {
            emptyRow = r;
            break;
        }
    }

    if (emptyRow === -1) return; // Column is full

    // Move cells down
    for (let r = emptyRow - 1; r >= 0; r--) {
        if (board[r][colIndex] !== 0) {
            board[emptyRow][colIndex] = board[r][colIndex];
            board[r][colIndex] = 0;
            emptyRow--;
        }
    }
}

--- END OF FILE: src/utils/board.utils.ts ---

--- START OF FILE: src/utils/constants.ts ---
/**
 * @fileoverview Defines constants used throughout the game.
 */

/** The number of columns on the game board. */
export const COLS = 10;
/** The number of rows on the game board. */
export const ROWS = 20;

/** The number of lines that must be cleared to advance to the next level. */
export const LEVEL_THRESHOLD = 10;

// --- Timings ---

// Animation timings
export const LINE_CLEAR_ANIMATION_DURATION = 300; // ms
export const SLOW_POWERUP_DURATION = 5000; // ms

// Input timings
export const DAS_DELAY = 160; // ms
export const ARR_INTERVAL = 40; // ms


/**
 * A mapping of piece color indices to their corresponding Tailwind CSS background color classes.
 */
export const PIECE_COLORS: { [key: number]: string } = {
  1: 'cyan-400',    // I
  2: 'blue-600',    // J
  3: 'orange-500',  // L
  4: 'yellow-400',  // O
  5: 'green-500',   // S
  6: 'purple-600',  // T
  7: 'red-600',     // Z
};

--- END OF FILE: src/utils/constants.ts ---

--- START OF FILE: src/utils/game-logic.utils.spec.ts ---
import { describe, it, expect } from 'vitest';
import { isValidPosition } from './game-logic.utils';
import { Piece } from './piece.interface';
import { COLS, ROWS } from './constants';
import { createEmptyBoard } from './board.utils';

describe('isValidPosition', () => {
  // Test case 1: A valid position
  it('should return true for a valid position within the board and without collisions', () => {
    const piece: Piece = {
      x: 3,
      y: 4,
      shape: [[1, 1], [1, 1]], // A square piece
    };
    const board = createEmptyBoard();
    expect(isValidPosition(piece, board)).toBe(true);
  });

  // Test case 2: Collision with a border
  it('should return false for a piece colliding with the right border', () => {
    const piece: Piece = {
      x: COLS - 1, // Positioned at the right edge
      y: 4,
      shape: [[1, 1], [1, 1]], // A square piece, part of it will be out of bounds
    };
    const board = createEmptyBoard();
    expect(isValidPosition(piece, board)).toBe(false);
  });

  it('should return false for a piece colliding with the left border', () => {
    const piece: Piece = {
      x: -1, // Positioned at the left edge
      y: 4,
      shape: [[1, 1], [1, 1]],
    };
    const board = createEmptyBoard();
    expect(isValidPosition(piece, board)).toBe(false);
  });

    it('should return false for a piece colliding with the bottom border', () => {
    const piece: Piece = {
      x: 3,
      y: ROWS -1, // Positioned at the bottom edge
      shape: [[1, 1], [1, 1]],
    };
    const board = createEmptyBoard();
    expect(isValidPosition(piece, board)).toBe(false);
  });

  // Test case 3: Collision with another piece
  it('should return false for a piece colliding with an existing piece on the board', () => {
    const piece: Piece = {
      x: 3,
      y: 4,
      shape: [[1, 1], [1, 1]],
    };
    const board = createEmptyBoard();
    // Place a block where the new piece wants to go
    board[5][4] = 2; // y=5, x=4 corresponds to the bottom-left of the piece
    expect(isValidPosition(piece, board)).toBe(false);
  });

  // Edge case: Piece is partially off the top of the board (which is valid)
  it('should return true for a piece that is partially above the board', () => {
    const piece: Piece = {
      x: 3,
      y: -1, // Spawn position, one row is hidden
      shape: [[1, 1], [1, 1]],
    };
    const board = createEmptyBoard();
    expect(isValidPosition(piece, board)).toBe(true);
  });
});

--- END OF FILE: src/utils/game-logic.utils.spec.ts ---

--- START OF FILE: src/utils/game-logic.utils.ts ---
/**
 * @fileoverview Core game logic utilities for collision detection, line clearing, and scoring.
 */

import { Piece } from './piece.interface';
import { COLS, ROWS } from './constants';

/**
 * Checks if a piece's position is valid on the board (not out of bounds or colliding with other pieces).
 * @param piece The piece to validate.
 * @param board The current game board.
 * @returns `true` if the position is valid, `false` otherwise.
 */
export function isValidPosition(piece: Piece, board: number[][]): boolean {
  for (let y = 0; y < piece.shape.length; y++) {
    for (let x = 0; x < piece.shape[y].length; x++) {
      if (piece.shape[y][x] > 0) {
        const boardX = piece.x + x;
        const boardY = piece.y + y;

        // Check bounds
        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
          return false;
        }

        // Check for collision with existing pieces (only for cells within the board's visible area)
        if (boardY >= 0 && board[boardY] && board[boardY][boardX] > 0) {
          return false;
        }
      }
    }
  }
  return true;
}

/**
 * Removes completed lines from the board and adds new empty lines at the top.
 * @param board The board to process.
 * @returns An object containing the new board and the number of lines cleared.
 */
export function clearLines(board: number[][]): { boardAfterClear: number[][], lines: number } {
  let lines = 0;
  const newBoard = board.filter(row => {
    if (row.every(cell => cell > 0)) {
      lines++;
      return false; // This row is full, so filter it out
    }
    return true; // This row is not full, keep it
  });

  // Add new empty rows at the top to maintain board height
  while (newBoard.length < ROWS) {
    newBoard.unshift(Array(COLS).fill(0));
  }

  return { boardAfterClear: newBoard, lines };
}

/** Base points for clearing 0, 1, 2, 3, or 4 lines at once. */
const LINE_POINTS = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4 lines

/**
 * Calculates the score awarded for clearing lines.
 * @param linesCleared The number of lines cleared at once.
 * @param level The current game level.
 * @returns The calculated score.
 */
export function calculateScore(linesCleared: number, level: number): number {
  return (LINE_POINTS[linesCleared] || 0) * level;
}

--- END OF FILE: src/utils/game-logic.utils.ts ---

--- START OF FILE: src/utils/piece.interface.ts ---
/**
 * @fileoverview Defines the interface for a Tetris piece.
 */

/**
 * Represents a Tetris piece, including its position and shape.
 */
export interface Piece {
  /** The x-coordinate of the piece's top-left corner on the board. */
  x: number;
  /** The y-coordinate of the piece's top-left corner on the board. */
  y: number;
  /** A 2D number array representing the shape and color of the piece. */
  shape: number[][];
}

--- END OF FILE: src/utils/piece.interface.ts ---

--- START OF FILE: src/utils/piece.utils.ts ---
/**
 * @fileoverview Utility functions for creating and manipulating Tetris pieces.
 */

import { COLS } from './constants';
import { Piece } from './piece.interface';

/**
 * Defines the shapes and color indices of all available Tetris pieces.
 */
const PIECES = [
  { shape: [[1, 1, 1, 1]], color: 1 }, // I
  { shape: [[2, 0, 0], [2, 2, 2]], color: 2 }, // J
  { shape: [[0, 0, 3], [3, 3, 3]], color: 3 }, // L
  { shape: [[4, 4], [4, 4]], color: 4 }, // O
  { shape: [[0, 5, 5], [5, 5, 0]], color: 5 }, // S
  { shape: [[0, 6, 0], [6, 6, 6]], color: 6 }, // T
  { shape: [[7, 7, 0], [0, 7, 7]], color: 7 }, // Z
];

/**
 * Creates a new, randomly selected Tetris piece at the top-center of the board.
 * @returns A new Piece object.
 */
export function getRandomPiece(): Piece {
  const type = PIECES[Math.floor(Math.random() * PIECES.length)];
  
  // The shape matrix is populated with the color index instead of just '1'
  const shapeWithColor = type.shape.map(row => row.map(cell => (cell > 0 ? type.color : 0)));

  return {
    x: Math.floor(COLS / 2) - Math.floor(type.shape[0].length / 2),
    y: 0,
    shape: shapeWithColor,
  };
}

/**
 * Rotates a piece's shape matrix 90 degrees clockwise.
 * @param piece The piece to rotate.
 * @returns A new piece object with the rotated shape.
 */
export function rotate(piece: Piece): Piece {
    const shape = piece.shape;
    // Transpose and reverse rows to achieve rotation
    const newShape = shape[0].map((_, colIndex) => shape.map(row => row[colIndex]).reverse());
    return { ...piece, shape: newShape };
}

--- END OF FILE: src/utils/piece.utils.ts ---

--- START OF FILE: tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "src/**/*.ts",
    "*.ts",
    "index.tsx"
  ],
  "angularCompilerOptions": {
    "disableTypeScriptVersionCheck": true
  }
}
--- END OF FILE: tsconfig.json ---

--- START OF FILE: vite.config.ts ---
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import angular from '@analogjs/vite-plugin-angular';

export default defineConfig({
  plugins: [
    angular({
      tsconfig: 'tsconfig.json',
    }),
  ],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['src/test-setup.ts'],
    include: ['src/**/*.spec.ts'],
  },
});

--- END OF FILE: vite.config.ts ---

