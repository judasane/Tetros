--- FLATTENED REPOSITORY SOURCE ---
Generated at: Thu Sep 18 16:05:17 UTC 2025
Branch: main
Commit: 4b4b3fc1b6258ea3aeadae16413eab1f6cbf95ec
------------------------------------

--- START OF FILE: .github/workflows/deploy.yml ---
name: Deploy to GitHub Pages
on:
  push:
    branches:
      - main
permissions:
  contents: read
  pages: write
  id-token: write
concurrency:
  group: "pages"
  cancel-in-progress: false
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm install
      - name: Build
        run: npm run build -- --base-href /${{ github.event.repository.name }}/
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./dist  # Quitar el /* - debe ser solo la carpeta
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

--- END OF FILE: .github/workflows/deploy.yml ---

--- START OF FILE: .github/workflows/flatten.yml ---
name: Create Flattened File

on:
  workflow_dispatch:

jobs:
  flatten-and-commit:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate flattened file
        run: |
          OUTPUT_FILE="flattened_output.txt"
          # Add or remove file extensions to exclude
          EXCLUDE_EXTENSIONS="map,tsbuildinfo,log,lock,db,sqlite,sqlite3,dump,lcov,png,jpg,jpeg,gif,ico,zip,gz,pdf,mp4,svg"
          # Add or remove specific filenames to exclude
          EXCLUDE_FILES="package-lock.json,yarn.lock,pnpm-lock.yaml"

          echo "--- FLATTENED REPOSITORY SOURCE ---" > "$OUTPUT_FILE"
          echo "Generated at: $(date)" >> "$OUTPUT_FILE"
          echo "Branch: ${GITHUB_REF##*/}" >> "$OUTPUT_FILE"
          echo "Commit: ${GITHUB_SHA}" >> "$OUTPUT_FILE"
          echo "------------------------------------" >> "$OUTPUT_FILE"
          echo "" >> "$OUTPUT_FILE"

          exclude_ext_pattern=$(echo "$EXCLUDE_EXTENSIONS" | sed 's/,/|/g')
          # Also exclude the output file itself
          exclude_files_pattern="$OUTPUT_FILE|$(echo "$EXCLUDE_FILES" | sed 's/,/|/g')"

          git ls-files | \
          grep -vE "\.($exclude_ext_pattern)$" | \
          grep -vE "^($exclude_files_pattern)$" | \
          while IFS= read -r file; do
              echo "--- START OF FILE: $file ---" >> "$OUTPUT_FILE"
              cat "$file" >> "$OUTPUT_FILE"
              echo -e "\n--- END OF FILE: $file ---\n" >> "$OUTPUT_FILE"
          done

          echo "âœ… Repository flattened into $OUTPUT_FILE"

      - name: Commit and push flattened file
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add $OUTPUT_FILE
          # Check if there are changes to commit to avoid empty commits
          if git diff --staged --quiet; then
            echo "No changes to commit. The flattened file is already up-to-date."
          else
            git commit -m "docs: Add/update flattened repository file" -m "This commit was generated by a GitHub Action."
            git push
          fi
        env:
          OUTPUT_FILE: "flattened_output.txt"

      - name: Upload artifact for easy download
        uses: actions/upload-artifact@v4
        with:
          name: flattened-repository-file
          path: flattened_output.txt
          if-no-files-found: error

--- END OF FILE: .github/workflows/flatten.yml ---

--- START OF FILE: .gitignore ---
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Angular cache
.angular/cache

--- END OF FILE: .gitignore ---

--- START OF FILE: .idx/dev.nix ---
@dev.nix{pkgs}: {
  channel = "stable-24.05";
  packages = [
    pkgs.nodejs_20
  ];
  idx.extensions = [
    "angular.ng-template"
  ];
  idx.previews = {
    previews = {
      web = {
        command = [
          "npm"
          "run"
          "dev"
          "--"
          "--port"
          "$PORT"
          "--host"
          "0.0.0.0"
        ];
        manager = "web";
      };
    };
  };
}
--- END OF FILE: .idx/dev.nix ---

--- START OF FILE: README.md ---
# Tetros: El Tejedor CÃ³smico

> *En la vasta y silenciosa expansiÃ³n donde nacen las estrellas y se desvanecen las galaxias, existe un telar de energÃ­a cÃ³smica. TÃº, alma valiente, eres el Tejedor, encargado de un deber eterno: dar forma al tejido mismo de la realidad a partir de fragmentos de luz estelar que caen.*

**Tetros** no es un simple juego; es una prueba de concentraciÃ³n, una danza de creaciÃ³n y disoluciÃ³n al borde del vacÃ­o. A medida que los bloques celestiales â€”los restos de estrellas moribundasâ€” descienden de los cielos, debes guiarlos, rotarlos y alinearlos en perfectos e ininterrumpidos filamentos cÃ³smicos.

Si fallas, el caos consumirÃ¡ el tablero. Si tienes Ã©xito, traerÃ¡s orden al universo, una lÃ­nea resplandeciente a la vez.

---
## El Arcano: Blandiendo Poderes EtÃ©reos

El cosmos ayuda a quienes demuestran su valÃ­a. Al alinear los filamentos, desbloquearÃ¡s potentes habilidades, poderosos encantamientos para doblegar la realidad a tu voluntad:

*   âš¡ï¸ **Rayo Celestial:** Desata un penetrante rayo de energÃ­a pura para aniquilar una lÃ­nea obstinada de la existencia.
*   â³ **Flujo Temporal:** Doblega el flujo del tiempo mismo, haciendo que los fragmentos de estrellas desciendan con una lentitud etÃ©rea.
*   âœ¨ **TransmutaciÃ³n CaÃ³tica:** Invoca la naturaleza impredecible del vacÃ­o, remodelando instantÃ¡neamente el fragmento que cae en una nueva forma.
*   ðŸ“¦ **Convergencia Destinada:** Contempla el tejido del destino, apuntando y eliminando con precisiÃ³n un Ãºnico bloque mal colocado para restaurar el equilibrio.

---
## Las Incantaciones: Controles del Tejedor

Para comandar los fragmentos celestiales, debes dominar estos antiguos ritos:

| Tecla(s)    | AcciÃ³n                      |
|-------------|-----------------------------|
| `â—„ â–º`       | Mover Fragmento Lateralmente|
| `â–²`         | Rotar Fragmento             |
| `â–¼`         | Acelerar Descenso           |
| `Espacio`   | Zambullida en el Abismo     |
| `C`         | Secuestrar Fragmento (Hold) |
| `P`         | Suspender el Tiempo (Pausa) |
| `1` - `4`   | Invocar Poder               |

---
## La InvocaciÃ³n: CÃ³mo Comenzar Tu Prueba

1.  Abre el portal arcano (tu navegador web).
2.  Concentra tu voluntad.
3.  Presiona **Start Game**.
4.  Teje tu destino.

> *El universo espera a su maestro. Â¿AceptarÃ¡s el desafÃ­o o te perderÃ¡s en la interminable cascada del caos?*
--- END OF FILE: README.md ---

--- START OF FILE: angular.json ---
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "",
  "projects": {
    "app": {
      "projectType": "application",
      "root": "",
      "sourceRoot": "./",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular/build:application",
          "options": {
            "outputPath": {
              "base": "./dist",
              "browser": "."
            },
            "browser": "index.tsx",
            "tsConfig": "tsconfig.json",
            "assets": [
              {
                "glob": "**/*",
                "input": "public",
                "output": "."
              }
            ]
          },
          "configurations": {
            "production": {
              "outputHashing": "all",
              "serviceWorker": "ngsw-config.json"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular/build:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "app:build:production"
            },
            "development": {
              "buildTarget": "app:build:development"
            }
          },
          "defaultConfiguration": "development"
        }
      }
    }
  }
}
--- END OF FILE: angular.json ---

--- START OF FILE: index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Tetros</title>
  <base href="/"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="theme-color" content="#0f172a">
  <link rel="icon" type="image/x-icon" href="favicon.ico"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Custom font for a game-like feel */
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    body {
      font-family: 'Press Start 2P', cursive;
      overflow: hidden;
    }

    @keyframes line-clear-flash {
      0%, 100% { 
        background-color: white; 
        transform: scale(1.05); 
        border-color: white;
      }
      50% { 
        background-color: #67e8f9; /* Tailwind cyan-300 */
        transform: scale(1.0); 
      }
    }
    .animate-line-clear {
      animation: line-clear-flash 0.3s ease-out;
    }
  </style>
<script type="importmap">
{
  "imports": {
    "rxjs": "https://aistudiocdn.com/rxjs@^7.8.2?conditions=es2015",
    "rxjs/operators": "https://aistudiocdn.com/rxjs@^7.8.2/operators?conditions=es2015",
    "rxjs/ajax": "https://aistudiocdn.com/rxjs@^7.8.2/ajax?conditions=es2015",
    "rxjs/webSocket": "https://aistudiocdn.com/rxjs@^7.8.2/webSocket?conditions=es2015",
    "rxjs/testing": "https://aistudiocdn.com/rxjs@^7.8.2/testing?conditions=es2015",
    "rxjs/fetch": "https://aistudiocdn.com/rxjs@^7.8.2/fetch?conditions=es2015",
    "@angular/platform-browser": "https://next.esm.sh/@angular/platform-browser@^20.1.6-0?external=rxjs",
    "@angular/core": "https://next.esm.sh/@angular/core@^20.1.6-0?external=rxjs",
    "@angular/compiler": "https://next.esm.sh/@angular/compiler@^20.1.6-0?external=rxjs",
    "@angular/common/http": "https://next.esm.sh/@angular/common@^20.1.6-0/http?external=rxjs"
  }
}
</script>
  <link rel="manifest" href="manifest.webmanifest">
</head>
<body class="bg-slate-900 text-white">
  <app-root></app-root>
  <noscript>Please enable JavaScript to continue using this application.</noscript>
</body>
</html>
--- END OF FILE: index.html ---

--- START OF FILE: index.tsx ---

import '@angular/compiler';
import { bootstrapApplication } from '@angular/platform-browser';
import { provideHttpClient } from '@angular/common/http';
import { provideZonelessChangeDetection, isDevMode } from '@angular/core';

import { AppComponent } from './src/app.component';
import { provideServiceWorker } from '@angular/service-worker';

bootstrapApplication(AppComponent, {
  providers: [
    provideZonelessChangeDetection(),
    provideHttpClient(), provideServiceWorker('ngsw-worker.js', {
            enabled: !isDevMode(),
            registrationStrategy: 'registerWhenStable:30000'
          }),
  ],
}).catch(err => console.error(err));

// AI Studio always uses an `index.tsx` file for all project types.

--- END OF FILE: index.tsx ---

--- START OF FILE: metadata.json ---
{
  "name": "Tetros",
  "description": "A modern twist on the classic Tetris game, combining falling block puzzles with exciting power-ups. Clear lines, level up, and use special abilities like lasers and slow motion to achieve a high score.",
  "requestFramePermissions": []
}
--- END OF FILE: metadata.json ---

--- START OF FILE: ngsw-config.json ---
{
  "$schema": "./node_modules/@angular/service-worker/config/schema.json",
  "index": "index.html",
  "assetGroups": [
    {
      "name": "app",
      "installMode": "prefetch",
      "resources": {
        "files": [
          "favicon.ico",
          "index.html",
          "manifest.webmanifest",
          "*.css",
          "*.js"
        ]
      }
    },
    {
      "name": "assets",
      "installMode": "lazy",
      "updateMode": "prefetch",
      "resources": {
        "files": [
          "/**/*.{svg,cur,jpg,jpeg,png,apng,webp,avif,gif,otf,ttf,woff,woff2}"
        ]
      }
    }
  ]
}

--- END OF FILE: ngsw-config.json ---

--- START OF FILE: package.json ---
{
  "name": "tetros",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "ng serve",
    "build": "ng build",
    "preview": "ng serve --configuration=production"
  },
  "dependencies": {
    "@angular/build": "^20.1.0",
    "@angular/cli": "^20.1.0",
    "@angular/common": "^20.1.0",
    "@angular/compiler": "^20.1.0",
    "@angular/compiler-cli": "^20.1.0",
    "@angular/core": "^20.1.0",
    "@angular/platform-browser": "^20.1.0",
    "@angular/service-worker": "^20.1.0",
    "rxjs": "^7.8.2",
    "tailwindcss": "latest"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  }
}
--- END OF FILE: package.json ---

--- START OF FILE: public/manifest.webmanifest ---
{
  "name": "Tetros",
  "short_name": "Tetros",
  "description": "Un juego de Tetris moderno",
  "theme_color": "#0f172a",
  "background_color": "#0f172a",
  "display": "standalone",
  "scope": "./",
  "start_url": "./",
  "icons": [
    {
      "src": "icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ]
}

--- END OF FILE: public/manifest.webmanifest ---

--- START OF FILE: src/app.component.css ---
/* Component-specific styles for AppComponent can go here. */

--- END OF FILE: src/app.component.css ---

--- START OF FILE: src/app.component.html ---
<div class="flex flex-col items-center justify-center min-h-screen p-2 sm:p-4 bg-slate-900 text-sm">

  <!-- Game Wrapper - A row on all screen sizes, centered on the page -->
  <div class="flex flex-row gap-4 items-start">
  
    <!-- Left Column -->
    <div class="flex flex-col gap-4">
      
      <!-- Powerups Panel -->
      <div [style.width.px]="boardWidth()">
        <app-info-panel title="PowerUps">
            <div class="grid grid-cols-4 gap-2 text-center">
                <button (click)="game.activatePowerUp('laser')" [disabled]="!game.canUsePowerUp('laser')" class="p-2 border-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed h-12 flex justify-center items-center" [class]="game.canUsePowerUp('laser') ? 'border-red-500 text-red-500 hover:bg-red-500/20' : 'border-slate-600 text-slate-600'">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" /></svg>
                </button>
                <button (click)="game.activatePowerUp('slow')" [disabled]="!game.canUsePowerUp('slow')" class="p-2 border-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed h-12 flex justify-center items-center" [class]="game.canUsePowerUp('slow') ? 'border-blue-500 text-blue-500 hover:bg-blue-500/20' : 'border-slate-600 text-slate-600'">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                </button>
                <button (click)="game.activatePowerUp('mutate')" [disabled]="!game.canUsePowerUp('mutate')" class="p-2 border-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed h-12 flex justify-center items-center" [class]="game.canUsePowerUp('mutate') ? 'border-purple-500 text-purple-500 hover:bg-purple-500/20' : 'border-slate-600 text-slate-600'">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.562L16.5 21.75l-.398-1.188a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.188-.398a2.25 2.25 0 001.423-1.423L16.5 15.75l.398 1.188a2.25 2.25 0 001.423 1.423L19.5 18.75l-1.188.398a2.25 2.25 0 00-1.423 1.423z" /></svg>
                </button>
                <button (click)="game.activatePowerUp('aimer')" [disabled]="!game.canUsePowerUp('aimer')" class="p-2 border-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed h-12 flex justify-center items-center" [class]="game.canUsePowerUp('aimer') ? 'border-yellow-500 text-yellow-500 hover:bg-yellow-500/20' : 'border-slate-600 text-slate-600'">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M21 7.5l-9-5.25L3 7.5m18 0l-9 5.25m9-5.25v9l-9 5.25M3 7.5l9 5.25M3 7.5v9l9 5.25m0-9v9" /></svg>
                </button>
            </div>
        </app-info-panel>
      </div>

      <!-- Game Board & Overlay -->
      <div 
        class="relative shadow-2xl shadow-cyan-500/20 border-4 border-slate-700 rounded-lg"
        (touchstart)="handleTouchStart($event)"
        (touchmove)="handleTouchMove($event)"
        (touchend)="handleTouchEnd($event)">
        <app-board 
            [board]="game.board()" 
            [currentPiece]="game.currentPiece()" 
            [ghostPiece]="game.ghostPiece()"
            [animationMode]="game.animationMode()"
            [dropProgress]="game.dropProgress()"
            [cellSize]="cellSize()"
             />
        <app-game-overlay 
            [gameState]="game.gameState()"
            [countdownValue]="game.countdownValue()"
            [animationMode]="game.animationMode()"
            (start)="game.startGame()" 
            (restart)="game.startGame()"
            (togglePause)="game.togglePause()"
            (toggleAnimation)="game.toggleAnimationMode()"
             />
      </div>
    </div>

    <!-- Right Column -->
    <div class="flex flex-col" [style.width.px]="boardWidth() / 3">
      
      <!-- Combined Info Panel -->
      <div class="w-full">
        <app-info-panel>
            <div class="flex flex-col justify-around items-center gap-4 py-2">
                <div class="flex flex-col items-center">
                    <h4 class="text-xs text-slate-400 mb-2 uppercase">Hold</h4>
                    @if (game.holdPiece(); as piece) {
                        <app-piece-preview [piece]="piece.shape" />
                    } @else {
                        <div class="w-16 h-12 flex items-center justify-center text-slate-600 text-xs rounded-md bg-slate-900/50">Empty</div>
                    }
                </div>
                <div class="flex flex-col items-center">
                    <h4 class="text-xs text-slate-400 mb-2 uppercase">Next</h4>
                    @if (game.nextPiece(); as piece) {
                        <app-piece-preview [piece]="piece.shape" />
                    } @else {
                        <div class="w-16 h-12 flex items-center justify-center text-slate-600 text-xs rounded-md bg-slate-900/50">Empty</div>
                    }
                </div>
                 <div class="flex flex-col items-center">
                      <h4 class="text-xs text-slate-400 mb-2 uppercase">Score</h4>
                      <p class="text-base lg:text-xl text-yellow-300">{{ game.score() }}</p>
                  </div>
                  <div class="flex flex-col items-center">
                      <h4 class="text-xs text-slate-400 mb-2 uppercase">Level</h4>
                      <p class="text-base lg:text-xl text-green-400">{{ game.level() }}</p>
                  </div>
                  <div class="flex flex-col items-center">
                      <h4 class="text-xs text-slate-400 mb-2 uppercase">Lines</h4>
                      <p class="text-base lg:text-xl text-purple-400">{{ game.linesCleared() }}</p>
                  </div>
            </div>
        </app-info-panel>
      </div>
      
    </div>
  </div>
</div>
--- END OF FILE: src/app.component.html ---

--- START OF FILE: src/app.component.ts ---
/**
 * @fileoverview Root component for the Tetros application.
 */
import { ChangeDetectionStrategy, Component, inject, signal, OnInit, computed } from '@angular/core';
import { GameService } from './services/game.service';
import { BoardComponent } from './components/board/board.component';
import { GameOverlayComponent } from './components/game-overlay/game-overlay.component';
import { InfoPanelComponent } from './components/info-panel/info-panel.component';
import { PiecePreviewComponent } from './components/piece-preview/piece-preview.component';
import { COLS, ROWS } from './utils/constants';

/**
 * The main application component.
 * It assembles the game's UI components and handles global keyboard and touch events for game control.
 */
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: true,
  imports: [
    BoardComponent,
    GameOverlayComponent,
    InfoPanelComponent,
    PiecePreviewComponent,
  ],
  providers: [GameService],
  host: {
    '(window:keydown)': 'handleKeyDown($event)',
    '(window:keyup)': 'handleKeyUp($event)',
    '(window:resize)': 'updateCellSize()'
  }
})
export class AppComponent implements OnInit {
  /** Injected instance of the GameService, which manages all game state and logic. */
  game = inject(GameService);

  /** The dynamically calculated size of a single board cell in pixels. */
  cellSize = signal(32);

  /** A signal indicating if the viewport is wide enough for the desktop layout. */
  isDesktop = signal(window.innerWidth >= 768);

  /** A computed signal for the total width of the game board in pixels. */
  boardWidth = computed(() => COLS * this.cellSize());

  // --- Touch Gesture State ---
  private touchStartX = 0;
  private touchStartY = 0;
  private touchStartTime = 0;
  private lastMoveX = 0;
  private lastMoveY = 0;
  private readonly swipeThreshold = 30; // Min pixels for a swipe
  private readonly tapThreshold = 20;   // Max pixels for a tap
  private readonly tapTimeThreshold = 200; // Max ms for a tap
  private readonly hardDropTimeThreshold = 250; // Max ms for a hard drop swipe
  
  /**
   * Initializes the component and performs the initial cell size calculation.
   */
  ngOnInit(): void {
    this.updateCellSize();
  }
  
  /**
   * Calculates and updates the optimal cell size based on the window's dimensions.
   * This logic assumes a persistent two-column layout.
   */
  updateCellSize(): void {
    this.isDesktop.set(window.innerWidth >= 768);

    // The layout is always a two-column flexbox.
    // The total game area width is ~4/3 of the board's width. Let's use 95% of the viewport width.
    const availableWidth = window.innerWidth * 0.95;
    // The board's container (left column) takes up roughly 3/4 of that space.
    const boardContainerWidth = availableWidth * 0.75;

    // Use 90% of the viewport height for the game area.
    const availableHeight = window.innerHeight * 0.90;
    
    // Calculate cell size based on available width for the board.
    const sizeByWidth = boardContainerWidth / COLS;
    // Calculate cell size based on available height, estimating space for the power-ups panel.
    // The powerups + board height is roughly equivalent to ROWS + 4 cells vertically.
    const sizeByHeight = availableHeight / (ROWS + 4); 
    
    this.cellSize.set(Math.floor(Math.min(sizeByHeight, sizeByWidth)));
  }

  /**
   * Handles the global 'keydown' event to process player inputs.
   * @param event The KeyboardEvent triggered by the key press.
   */
  handleKeyDown(event: KeyboardEvent): void {
    if (event.repeat) return;
    if (this.game.gameState() === 'gameover' || this.game.isAiming()) {
      if (this.game.isAiming()) this.game.handleAimerKeys(event.key);
      return;
    }
    if (this.game.gameState() === 'start' && event.key === 'Enter') {
      this.game.startGame();
      return;
    }
    if (this.game.gameState() === 'countdown' || this.game.gameState() === 'clearing') return;
    if (event.key === 'p' || event.key === 'P') {
      this.game.togglePause();
      return;
    }
    if (this.game.gameState() === 'paused') return;
    this.game.pressKey(event.key);
  }

  /**
   * Handles the global 'keyup' event to stop continuous actions.
   * @param event The KeyboardEvent triggered by the key release.
   */
  handleKeyUp(event: KeyboardEvent): void {
    this.game.releaseKey(event.key);
  }

  /**
   * Records the starting coordinates of a touch event.
   * @param event The TouchEvent.
   */
  handleTouchStart(event: TouchEvent): void {
    if (this.game.gameState() !== 'playing') return;
    event.preventDefault();
    this.touchStartX = event.touches[0].clientX;
    this.touchStartY = event.touches[0].clientY;
    this.touchStartTime = Date.now();
    this.lastMoveX = this.touchStartX;
    this.lastMoveY = this.touchStartY;
  }

  /**
   * Processes touch movement to detect and handle swipes.
   * @param event The TouchEvent.
   */
  handleTouchMove(event: TouchEvent): void {
    if (this.game.gameState() !== 'playing') return;
    event.preventDefault();
    const touchX = event.touches[0].clientX;
    const touchY = event.touches[0].clientY;

    const deltaX = touchX - this.lastMoveX;
    const deltaY = touchY - this.lastMoveY;
    
    const horizontalMoveThreshold = this.cellSize() * 0.8;
    const verticalMoveThreshold = this.cellSize() * 0.8;

    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > horizontalMoveThreshold) {
      if (deltaX > 0) this.game.moveRight();
      else this.game.moveLeft();
      this.lastMoveX = touchX;
    } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > verticalMoveThreshold) {
      this.game.softDrop();
      this.lastMoveY = touchY;
    }
  }

  /**
   * Processes the end of a touch to detect taps and hard drops.
   * @param event The TouchEvent.
   */
  handleTouchEnd(event: TouchEvent): void {
    if (this.game.gameState() !== 'playing') return;
    event.preventDefault();
    const touchEndX = event.changedTouches[0].clientX;
    const touchEndY = event.changedTouches[0].clientY;

    const deltaX = touchEndX - this.touchStartX;
    const deltaY = touchEndY - this.touchStartY;
    const elapsedTime = Date.now() - this.touchStartTime;

    // Check for Tap (Rotate)
    if (Math.abs(deltaX) < this.tapThreshold && Math.abs(deltaY) < this.tapThreshold && elapsedTime < this.tapTimeThreshold) {
      this.game.rotate();
      return;
    }

    // Check for Hard Drop (fast, long downward swipe)
    if (deltaY > this.swipeThreshold * 2.5 && deltaY > Math.abs(deltaX) && elapsedTime < this.hardDropTimeThreshold) {
      this.game.hardDrop();
      return;
    }
  }
}
--- END OF FILE: src/app.component.ts ---

--- START OF FILE: src/components/board/board.component.css ---
/* Component-specific styles for BoardComponent can go here. */

--- END OF FILE: src/components/board/board.component.css ---

--- START OF FILE: src/components/board/board.component.html ---
<div 
  class="relative bg-slate-800/50 overflow-hidden grid" 
  [style.grid-template-columns]="'repeat(' + COLS + ', ' + cellSize() + 'px)'"
  [style.width.px]="COLS * cellSize()"
>
  <!-- The static board grid for locked pieces -->
  @for (row of boardToRender(); track $index) {
    @for (cell of row; track $index) {
      <app-cell [value]="cell" />
    }
  }

  <!-- The smoothly animated ghost piece -->
  @if (ghostPiece(); as ghost) {
    <app-falling-piece 
        [piece]="ghost" 
        [isGhost]="true" 
        [animationMode]="animationMode()"
        [cellSize]="cellSize()"
        />
  }

  <!-- The smoothly animated current piece -->
  @if (currentPiece(); as piece) {
    <app-falling-piece 
        [piece]="piece"
        [animationMode]="animationMode()"
        [dropProgress]="dropProgress()"
        [cellSize]="cellSize()"
        />
  }
</div>

--- END OF FILE: src/components/board/board.component.html ---

--- START OF FILE: src/components/board/board.component.ts ---
/**
 * @fileoverview Component for rendering the main game board.
 */
import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';
import { CellComponent } from '../cell/cell.component';
import { COLS } from '../../utils/constants';
import { Piece } from '../../utils/piece.interface';
import { FallingPieceComponent } from '../falling-piece/falling-piece.component';

/**
 * Renders the game board, including the static grid of locked pieces
 * and the animated falling and ghost pieces.
 */
@Component({
  selector: 'app-board',
  standalone: true,
  imports: [CellComponent, FallingPieceComponent],
  templateUrl: './board.component.html',
  styleUrls: ['./board.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class BoardComponent {
  /** The number of columns on the board. */
  readonly COLS = COLS;
  
  /** The 2D array representing the static, locked-in pieces on the board. */
  boardInput = input.required<number[][]>({ alias: 'board' });
  
  /** The currently falling piece, or null if none. */
  currentPiece = input.required<Piece | null>();
  
  /** The ghost piece showing the final drop position, or null if none. */
  ghostPiece = input.required<Piece | null>();

  /** The user-selected animation mode for piece movement. */
  animationMode = input<'step' | 'smooth'>('smooth');

  /** The fractional progress of the current piece's drop between two cells (0 to 1), used for smooth animation. */
  dropProgress = input<number>(0);

  /** The size of a single cell in pixels, used for dynamic board scaling. */
  cellSize = input<number>(32);

  /** A computed signal that directly passes the board input to the template. */
  boardToRender = computed(() => this.boardInput());
}

--- END OF FILE: src/components/board/board.component.ts ---

--- START OF FILE: src/components/cell/cell.component.css ---
/* Component-specific styles for CellComponent can go here. */

--- END OF FILE: src/components/cell/cell.component.css ---

--- START OF FILE: src/components/cell/cell.component.html ---
<div 
  class="aspect-square border border-slate-700/50" 
  [class]="cellClass()">
</div>

--- END OF FILE: src/components/cell/cell.component.html ---

--- START OF FILE: src/components/cell/cell.component.ts ---
/**
 * @fileoverview Component for a single cell on the game board.
 */
import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';
import { PIECE_COLORS } from '../../utils/constants';

/**
 * Represents a single cell in the game grid. Its appearance is determined
 * by the numeric `value` input.
 */
@Component({
  selector: 'app-cell',
  standalone: true,
  templateUrl: './cell.component.html',
  styleUrls: ['./cell.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CellComponent {
  /** 
   * The numeric value of the cell which determines its state and appearance.
   * - `0`: Empty
   * - `> 0`: A locked piece, value corresponds to a color index.
   * - `-1`: Ghost piece preview.
   * - `-2`: Aimer power-up target.
   * - `-3`: Part of a line being cleared.
   */
  value = input.required<number>();

  /**
   * Computes the appropriate Tailwind CSS classes for the cell based on its value.
   * @returns A string of CSS classes.
   */
  cellClass = computed(() => {
    const val = this.value();
    if (val > 0) {
      // Piece
      return `bg-${PIECE_COLORS[val]} shadow-inner shadow-white/20`;
    }
    if (val === -1) {
      // Ghost piece
      return 'bg-slate-500/30 border border-slate-400/50';
    }
     if (val === -2) {
      // Aimer target
      return 'bg-yellow-500/70 animate-pulse border-2 border-yellow-300';
    }
    if (val === -3) {
      // Line clearing animation
      return 'animate-line-clear';
    }
    // Empty cell
    return 'bg-slate-800';
  });
}

--- END OF FILE: src/components/cell/cell.component.ts ---

--- START OF FILE: src/components/falling-piece/falling-piece.component.css ---
/* Component-specific styles for FallingPieceComponent can go here. */

--- END OF FILE: src/components/falling-piece/falling-piece.component.css ---

--- START OF FILE: src/components/falling-piece/falling-piece.component.html ---
<div 
  class="absolute grid z-20"
  [style.transition]="transitionStyle()"
  [style.left.px]="position().left"
  [style.top.px]="position().top"
  [style.grid-template-columns]="'repeat(' + (pieceShape()[0]?.length || 0) + ', ' + cellSize() + 'px)'"
  [class.opacity-40]="isGhost()">
  @for (row of pieceShape(); track $index) {
    @for (cell of row; track $index) {
      <div 
        class="aspect-square"
        [style.width.px]="cellSize()"
        [style.height.px]="cellSize()"
        [class]="getCellClass(cell)">
      </div>
    }
  }
</div>

--- END OF FILE: src/components/falling-piece/falling-piece.component.html ---

--- START OF FILE: src/components/falling-piece/falling-piece.component.ts ---
/**
 * @fileoverview Component for rendering the animated, currently falling piece.
 */
import { ChangeDetectionStrategy, Component, computed, input } from '@angular/core';
import { Piece } from '../../utils/piece.interface';
import { PIECE_COLORS } from '../../utils/constants';

/**
 * A component dedicated to rendering the currently falling piece and its ghost.
 * It is positioned absolutely over the main board and uses CSS transitions for smooth movement.
 */
@Component({
  selector: 'app-falling-piece',
  standalone: true,
  templateUrl: './falling-piece.component.html',
  styleUrls: ['./falling-piece.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class FallingPieceComponent {
  /** The piece object to be rendered. */
  piece = input.required<Piece>();
  /** Whether this piece should be rendered as a semi-transparent ghost. */
  isGhost = input<boolean>(false);
  /** The current animation mode ('step' or 'smooth'). */
  animationMode = input<'step' | 'smooth'>('smooth');
  /** The fractional progress (0-1) of the piece's drop, for smooth animation. */
  dropProgress = input<number>(0);
  /** The size of a single cell in pixels, used for dynamic scaling. */
  cellSize = input<number>(32);

  /** A computed signal for the piece's shape matrix. */
  pieceShape = computed(() => this.piece().shape);
  
  /**
   * Computes the `top` and `left` CSS properties in pixels for positioning the piece.
   * In smooth mode, it incorporates `dropProgress` for fluid vertical movement.
   */
  position = computed(() => {
    const piece = this.piece();
    const size = this.cellSize();
    // In smooth mode, add the fractional drop progress for a fluid animation.
    const yOffset = (this.animationMode() === 'smooth' && !this.isGhost()) 
      ? this.dropProgress() 
      : 0;
    
    return {
        left: piece.x * size,
        top: (piece.y + yOffset) * size,
    };
  });

  /**
   * Computes the `transition` CSS property based on the animation mode.
   * In 'smooth' mode, vertical transitions are disabled as `top` is updated per frame.
   * In 'step' mode, all transforms are transitioned.
   */
  transitionStyle = computed(() => {
    const duration = '100ms';
    const timing = 'ease-out';
    
    // The ghost piece should always have a quick transition for all movements.
    if (this.isGhost()) {
      return `all ${duration} ${timing}`;
    }

    // In smooth mode, `top` is updated every frame, so we only transition horizontal movement.
    if (this.animationMode() === 'smooth') {
      return `left ${duration} ${timing}`;
    }

    // In step mode, we transition all movements for a classic, snappy feel.
    return `all ${duration} ${timing}`;
  });

  /** Private reference to the color map. */
  private colors = PIECE_COLORS;
  
  /**
   * Gets the appropriate CSS classes for a single cell within the falling piece.
   * @param cellValue The numeric value of the cell from the piece's shape matrix.
   * @returns A string of Tailwind CSS classes.
   */
  getCellClass(cellValue: number): string {
    if (cellValue <= 0) {
      return 'bg-transparent';
    }
    if (this.isGhost()) {
      return 'bg-slate-500/30 border border-slate-400/50';
    }
    return `bg-${this.colors[cellValue]} shadow-inner shadow-white/20 border border-slate-700/50`;
  }
}

--- END OF FILE: src/components/falling-piece/falling-piece.component.ts ---

--- START OF FILE: src/components/game-overlay/game-overlay.component.css ---
/* Component-specific styles for GameOverlayComponent can go here. */

--- END OF FILE: src/components/game-overlay/game-overlay.component.css ---

--- START OF FILE: src/components/game-overlay/game-overlay.component.html ---
 @if (gameState() === 'start' || gameState() === 'paused' || gameState() === 'gameover' || gameState() === 'countdown') {
  <div class="absolute inset-0 bg-black/70 flex flex-col justify-center items-center text-center backdrop-blur-sm z-30 p-4">
    @switch (gameState()) {
      @case ('start') {
        <h2 class="text-3xl font-bold text-cyan-400 mb-4">Welcome!</h2>
        <button (click)="start.emit()" class="px-6 py-3 bg-green-600 hover:bg-green-500 rounded-md text-xl animate-pulse">Start Game</button>
         <div class="mt-8 text-left text-sm max-w-xs">
            <h3 class="text-lg text-cyan-400 mb-2 text-center uppercase tracking-widest">Controls</h3>
            <ul class="text-xs space-y-1 text-slate-300">
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Arrows:</span> Move</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Up:</span> Rotate</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Space:</span> Hard Drop</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">C:</span> Hold</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">P:</span> Pause</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">1-4:</span> Power-ups</li>
           </ul>
        </div>
      }
      @case ('paused') {
        <h2 class="text-3xl font-bold text-yellow-400 mb-6">Paused</h2>
        <div class="flex flex-col gap-4 w-full max-w-[220px] mb-6">
            <button (click)="togglePause.emit()" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-md text-base w-full">Resume</button>
            <button (click)="restart.emit()" class="px-4 py-2 border-2 border-green-500 text-green-500 hover:bg-green-500/20 transition-colors rounded-md text-base w-full">Restart</button>
            <button (click)="toggleAnimation.emit()" class="px-4 py-2 border-2 border-cyan-500 text-cyan-500 hover:bg-cyan-500/20 transition-colors rounded-md text-xs w-full capitalize">
                Animation: {{ animationMode() }}
            </button>
        </div>
         <div class="text-left text-sm max-w-xs">
            <h3 class="text-lg text-cyan-400 mb-2 text-center uppercase tracking-widest">Controls</h3>
            <ul class="text-xs space-y-1 text-slate-300">
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Arrows:</span> Move</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Up:</span> Rotate</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">Space:</span> Hard Drop</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">C:</span> Hold</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">P:</span> Pause</li>
             <li><span class="font-bold text-cyan-400 w-20 inline-block">1-4:</span> Power-ups</li>
           </ul>
        </div>
      }
      @case ('gameover') {
        <h2 class="text-3xl font-bold text-red-500 mb-4">Game Over</h2>
        <button (click)="restart.emit()" class="px-6 py-3 bg-green-600 hover:bg-green-500 rounded-md text-xl">Play Again</button>
      }
      @case ('countdown') {
        <div class="text-8xl font-bold text-white animate-pulse">{{ countdownValue() }}</div>
      }
    }
  </div>
}
--- END OF FILE: src/components/game-overlay/game-overlay.component.html ---

--- START OF FILE: src/components/game-overlay/game-overlay.component.ts ---
/**
 * @fileoverview Component for displaying overlay screens like "Start", "Paused", and "Game Over".
 */
import { ChangeDetectionStrategy, Component, input, output } from '@angular/core';

/**
 * A UI component that displays contextual overlays based on the current game state.
 * It provides buttons for the player to interact with the game state (e.g., start, pause, restart).
 */
@Component({
  selector: 'app-game-overlay',
  standalone: true,
  templateUrl: './game-overlay.component.html',
  styleUrls: ['./game-overlay.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class GameOverlayComponent {
  /** The current state of the game, which determines which overlay to show. */
  gameState = input.required<'start' | 'playing' | 'paused' | 'gameover' | 'countdown' | 'clearing'>();
  
  /** The remaining seconds for the start-of-game countdown. */
  countdownValue = input<number>(0);

  /** The current animation mode, displayed in the pause menu. */
  animationMode = input<'step' | 'smooth'>('smooth');

  /** Emits when the "Start Game" button is clicked. */
  start = output<void>();
  
  /** Emits when a "Restart" or "Play Again" button is clicked. */
  restart = output<void>();

  /** Emits when the "Resume" button is clicked. */
  togglePause = output<void>();

  /** Emits when the animation mode toggle button is clicked. */
  toggleAnimation = output<void>();
}

--- END OF FILE: src/components/game-overlay/game-overlay.component.ts ---

--- START OF FILE: src/components/info-panel/info-panel.component.css ---
/* Component-specific styles for InfoPanelComponent can go here. */

--- END OF FILE: src/components/info-panel/info-panel.component.css ---

--- START OF FILE: src/components/info-panel/info-panel.component.html ---
<div class="bg-slate-800/80 p-2 md:p-3 lg:p-4 rounded-lg border-2 border-slate-700 shadow-lg shadow-cyan-500/10 h-full">
  @if (title()) {
    <h3 class="text-[11px] sm:text-xs font-bold text-cyan-400 uppercase mb-2 tracking-normal md:tracking-widest text-center">{{ title() }}</h3>
  }
  <ng-content></ng-content>
</div>
--- END OF FILE: src/components/info-panel/info-panel.component.html ---

--- START OF FILE: src/components/info-panel/info-panel.component.ts ---
/**
 * @fileoverview A reusable panel component for displaying game information.
 */
import { ChangeDetectionStrategy, Component, input } from '@angular/core';

/**
 * A generic, styled container component with a title. It is used to display
 * various pieces of game information like score, next piece, etc., using content projection.
 */
@Component({
  selector: 'app-info-panel',
  standalone: true,
  templateUrl: './info-panel.component.html',
  styleUrls: ['./info-panel.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class InfoPanelComponent {
  /** The title to be displayed at the top of the panel. */
  title = input<string | undefined>();
}
--- END OF FILE: src/components/info-panel/info-panel.component.ts ---

--- START OF FILE: src/components/piece-preview/piece-preview.component.css ---
/* Component-specific styles for PiecePreviewComponent can go here. */

--- END OF FILE: src/components/piece-preview/piece-preview.component.css ---

--- START OF FILE: src/components/piece-preview/piece-preview.component.html ---
<div class="grid" [style.grid-template-columns]="'repeat(' + piece()[0].length + ', 1fr)'">
  @for (row of piece(); track $index) {
    @for (cell of row; track $index) {
      <div 
        class="aspect-square w-4 h-4"
        [class]="cell > 0 ? 'bg-' + colors[cell] : 'bg-transparent'">
      </div>
    }
  }
</div>
--- END OF FILE: src/components/piece-preview/piece-preview.component.html ---

--- START OF FILE: src/components/piece-preview/piece-preview.component.ts ---
/**
 * @fileoverview Component for displaying a small preview of a Tetris piece.
 */
import { ChangeDetectionStrategy, Component, input } from '@angular/core';
import { PIECE_COLORS } from '../../utils/constants';

/**
 * Renders a small, static preview of a given piece shape.
 * Used for the "Next" and "Hold" displays.
 */
@Component({
  selector: 'app-piece-preview',
  standalone: true,
  templateUrl: './piece-preview.component.html',
  styleUrls: ['./piece-preview.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PiecePreviewComponent {
  /** The 2D array representing the shape of the piece to be displayed. */
  piece = input.required<number[][]>();
  
  /** A map of color indices to Tailwind CSS color names. */
  colors = PIECE_COLORS;
}

--- END OF FILE: src/components/piece-preview/piece-preview.component.ts ---

--- START OF FILE: src/services/game.service.ts ---
/**
 * @fileoverview Manages the core game state and logic for Tetros.
 */
import { Injectable, computed, signal } from '@angular/core';
import { createEmptyBoard, applyGravityToColumn } from '../utils/board.utils';
import { isValidPosition, clearLines, calculateScore } from '../utils/game-logic.utils';
import { getRandomPiece, rotate } from '../utils/piece.utils';
import { Piece } from '../utils/piece.interface';
import { COLS, LEVEL_THRESHOLD, ROWS } from '../utils/constants';

/** Represents the possible states of the game. */
type GameState = 'start' | 'playing' | 'paused' | 'gameover' | 'countdown' | 'clearing';
/** Represents the types of available power-ups. */
type PowerUp = 'laser' | 'slow' | 'mutate' | 'aimer';
/** Represents the available animation styles for piece movement. */
type AnimationMode = 'step' | 'smooth';

/**
 * Service responsible for all game logic, state management, and player actions.
 */
@Injectable()
export class GameService {
  // --- Game State Signals ---
  /** The main game board, a 2D array of numbers representing cell states. */
  board = signal(createEmptyBoard());
  /** The currently falling piece controlled by the player. */
  currentPiece = signal<Piece | null>(null);
  /** The upcoming piece. */
  nextPiece = signal<Piece | null>(null);
  /** The piece currently in the hold slot. */
  holdPiece = signal<Piece | null>(null);
  /** The current state of the game finite state machine. */
  gameState = signal<GameState>('start');
  /** The player's current score. */
  score = signal(0);
  /** The current game level, which affects drop speed. */
  level = signal(1);
  /** The total number of lines cleared by the player. */
  linesCleared = signal(0);
  /** A flag to prevent holding a piece more than once per turn. */
  isHoldingAllowed = signal(true);
  /** The value for the pre-game countdown timer. */
  countdownValue = signal(0);
  
  // --- Animation Signals ---
  /** The selected animation style for piece movement. */
  animationMode = signal<AnimationMode>('smooth');
  /** The fractional progress (0-1) of the current piece's fall, used for smooth animation. */
  dropProgress = signal(0);
  
  // --- Power-Up Signals ---
  /** A map tracking the count of available power-ups. */
  powerUps = signal<{[key in PowerUp]: number}>({ laser: 1, slow: 1, mutate: 1, aimer: 1 });
  /** Flag indicating if the 'aimer' power-up is currently active. */
  isAiming = signal(false);
  /** The coordinates of the aimer's target on the board. */
  aimerPosition = signal({ x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2) });
  
  // --- Private State ---
  /** Timestamp of the last frame in the game loop. */
  private lastTime = 0;
  /** Accumulator for time elapsed since the last automatic drop. */
  private dropCounter = 0;
  /** Flag indicating if the 'slow' power-up is active. */
  private slowMotionActive = false;
  /** ID of the interval timer for the pre-game countdown. */
  private countdownIntervalId: any = null;

  // --- Keyboard Control State (DAS/ARR) ---
  /** Timer for Delayed Auto-Shift (DAS) delay. */
  private dasTimer: any = null;
  /** Timer for Auto-Repeat Rate (ARR) interval. */
  private arrTimer: any = null;
  /** Timer for soft drop auto-repeat. */
  private readonly dasDelay = 160; // ms
  private readonly arrInterval = 40;  // ms
  private softDropInterval: any = null;


  /**
   * A computed signal that calculates the position of the ghost piece.
   * The ghost piece shows where the current piece will land.
   */
  ghostPiece = computed(() => {
    const piece = this.currentPiece();
    if (!piece || this.gameState() !== 'playing') return null;

    let ghost = { ...piece, shape: piece.shape.map(row => [...row]) };
    while (isValidPosition(ghost, this.board())) {
      ghost.y++;
    }
    ghost.y--;
    return ghost;
  });

  /**
   * Checks if a specific power-up can be used.
   * @param powerUp The power-up to check.
   * @returns `true` if the power-up can be used, otherwise `false`.
   */
  canUsePowerUp(powerUp: PowerUp): boolean {
    return this.powerUps()[powerUp] > 0 && this.gameState() === 'playing' && !this.isAiming();
  }

  /**
   * Initializes or restarts the game, resetting all state variables and starting the countdown.
   */
  startGame(): void {
    if (this.countdownIntervalId) {
        clearInterval(this.countdownIntervalId);
        this.countdownIntervalId = null;
    }
    // Clear any active movement timers from a previous game
    if (this.dasTimer) clearTimeout(this.dasTimer);
    if (this.arrTimer) clearInterval(this.arrTimer);
    if (this.softDropInterval) clearInterval(this.softDropInterval);
    this.dasTimer = null;
    this.arrTimer = null;
    this.softDropInterval = null;


    this.board.set(createEmptyBoard());
    this.currentPiece.set(getRandomPiece());
    this.nextPiece.set(getRandomPiece());
    this.holdPiece.set(null);
    this.score.set(0);
    this.level.set(1);
    this.linesCleared.set(0);
    this.isHoldingAllowed.set(true);
    this.powerUps.set({ laser: 1, slow: 1, mutate: 1, aimer: 1 });
    this.isAiming.set(false);
    this.aimerPosition.set({ x: Math.floor(COLS / 2), y: Math.floor(ROWS / 2) });
    this.slowMotionActive = false;

    this.gameState.set('countdown');
    this.countdownValue.set(3);

    this.countdownIntervalId = setInterval(() => {
      this.countdownValue.update(v => v - 1);
      if (this.countdownValue() <= 0) {
        if(this.countdownIntervalId) clearInterval(this.countdownIntervalId);
        this.countdownIntervalId = null;
        this.gameState.set('playing');
        this.lastTime = 0;
        this.dropCounter = 0;
        this.dropProgress.set(0);
        requestAnimationFrame((time) => this.gameLoop(time));
      }
    }, 1000);
  }

  /**
   * Toggles the game between 'playing' and 'paused' states.
   */
  togglePause(): void {
    if (this.gameState() === 'playing') {
      this.gameState.set('paused');
    } else if (this.gameState() === 'paused') {
      this.gameState.set('playing');
      this.lastTime = 0; // Reset time to avoid a sudden drop
      requestAnimationFrame((time) => this.gameLoop(time));
    }
  }

  /**
   * The main game loop, driven by `requestAnimationFrame`.
   * It calculates delta time to handle piece dropping and animations.
   * @param time The high-resolution timestamp provided by `requestAnimationFrame`.
   */
  private gameLoop(time: number): void {
    if (this.gameState() !== 'playing') return;

    if (this.lastTime === 0) {
      this.lastTime = time;
    }
    const deltaTime = time - this.lastTime;
    this.lastTime = time;
    this.dropCounter += deltaTime;
    
    const dropInterval = (1000 / this.level()) * (this.slowMotionActive ? 3 : 1);

    if (!this.softDropInterval) {
      while (this.dropCounter >= dropInterval) {
        this.moveDown();
        if (this.gameState() !== 'playing') {
          this.dropProgress.set(0);
          return; // Exit loop if game state changes (e.g., game over)
        }
        this.dropCounter -= dropInterval;
      }
    }

    if (this.currentPiece()) {
      // If the piece is resting on something, don't apply drop progress to prevent visual overshoot.
      if (this.canMoveDown()) {
        this.dropProgress.set(Math.min(1, this.dropCounter / dropInterval));
      } else {
        this.dropProgress.set(0);
      }
    } else {
      this.dropProgress.set(0);
    }

    requestAnimationFrame((t) => this.gameLoop(t));
  }

  /**
   * Moves the current piece one cell to the left, if possible.
   */
  moveLeft(): void {
    this.movePiece(-1, 0);
  }

  /**
   * Moves the current piece one cell to the right, if possible.
   */
  moveRight(): void {
    this.movePiece(1, 0);
  }
  
  /**
   * Moves the current piece one cell down (soft drop).
   */
  softDrop(): void {
    this.moveDown();
    this.dropCounter = 0; // Reset counter for immediate feedback
    this.dropProgress.set(0);
  }

  /**
   * Instantly drops the current piece to its final position and locks it.
   */
  hardDrop(): void {
    const piece = this.currentPiece();
    const ghost = this.ghostPiece();
    if (piece && ghost) {
      const droppedPiece = { ...piece, y: ghost.y };
      this.currentPiece.set(droppedPiece);
      this.lockPiece();
    }
  }

  /**
   * Rotates the current piece clockwise, applying wall kicks if necessary.
   */
  rotate(): void {
    const piece = this.currentPiece();
    if (!piece) return;

    const rotatedPiece = rotate(piece);

    // Try to find a valid position by "kicking" the piece.
    // This is a simplified wall kick, not full SRS.
    const kicks = [
      { x: 0, y: 0 },   // No kick
      { x: 1, y: 0 },   // Kick right 1
      { x: -1, y: 0 },  // Kick left 1
      { x: 2, y: 0 },   // Kick right 2 (for I piece)
      { x: -2, y: 0 },  // Kick left 2 (for I piece)
      { x: 0, y: -1 }   // Kick up 1
    ];

    for (const kick of kicks) {
      const kickedPiece = {
        ...rotatedPiece,
        x: rotatedPiece.x + kick.x,
        y: rotatedPiece.y + kick.y
      };

      if (isValidPosition(kickedPiece, this.board())) {
        this.currentPiece.set(kickedPiece);
        return; // Rotation successful
      }
    }
    // If no kick works, rotation fails.
  }

  /**
   * Swaps the current piece with the piece in the hold slot.
   */
  hold(): void {
    if (!this.isHoldingAllowed() || this.gameState() !== 'playing') return;
    const current = this.currentPiece();
    const held = this.holdPiece();

    this.holdPiece.set({...current!, x: 3, y: 0});
    if (held) {
        this.currentPiece.set({...held, x: 3, y: 0});
    } else {
        this.spawnNewPiece();
    }
    this.isHoldingAllowed.set(false);
  }

  /**
   * Checks if the current piece can move one cell down.
   * @returns `true` if the piece can move down, `false` otherwise.
   */
  private canMoveDown(): boolean {
    const piece = this.currentPiece();
    if (!piece) return false;
    const newPiece = { ...piece, y: piece.y + 1 };
    return isValidPosition(newPiece, this.board());
  }

  /**
   * Attempts to move the piece one step down. If it fails, the piece is locked.
   */
  private moveDown(): void {
    if (this.movePiece(0, 1)) {
        // Piece moved down successfully
    } else {
        this.lockPiece();
    }
  }
  
  /**
   * Attempts to move the current piece by a given delta.
   * @param dx The change in the x-coordinate.
   * @param dy The change in the y-coordinate.
   * @returns `true` if the move was successful, `false` otherwise.
   */
  private movePiece(dx: number, dy: number): boolean {
    const piece = this.currentPiece();
    if (!piece) return false;
    const newPiece = { ...piece, x: piece.x + dx, y: piece.y + dy };
    if (isValidPosition(newPiece, this.board())) {
      this.currentPiece.set(newPiece);
      return true;
    }
    return false;
  }

  /**
   * Locks the current piece onto the board, checks for line clears, and spawns the next piece.
   */
  private lockPiece(): void {
    const piece = this.currentPiece();
    if (!piece) return;

    const boardWithPiece = this.board().map(row => [...row]);
    piece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value > 0) {
          const boardX = piece.x + x;
          const boardY = piece.y + y;
          if(boardY >= 0) {
            boardWithPiece[boardY][boardX] = value;
          }
        }
      });
    });

    const linesToClear: number[] = [];
    boardWithPiece.forEach((row, y) => {
        if (row.every(cell => cell > 0)) {
            linesToClear.push(y);
        }
    });

    if (linesToClear.length > 0) {
        this.gameState.set('clearing');
        this.currentPiece.set(null);

        const animationBoard = boardWithPiece.map((row, y) => {
            if (linesToClear.includes(y)) {
                return Array(COLS).fill(-3); // -3 for clearing animation
            }
            return row;
        });
        this.board.set(animationBoard);

        setTimeout(() => {
            const { boardAfterClear, lines } = clearLines(boardWithPiece);
            this.board.set(boardAfterClear);

            if (lines > 0) {
                this.score.update(s => s + calculateScore(lines, this.level()));
                this.linesCleared.update(l => l + lines);
                this.level.set(Math.floor(this.linesCleared() / LEVEL_THRESHOLD) + 1);
                this.powerUps.update(p => ({ laser: p.laser+1, slow: p.slow+1, mutate: p.mutate+1, aimer: p.aimer+1 }));
            }

            this.spawnNewPiece();
            this.isHoldingAllowed.set(true);
            this.gameState.set('playing');
            this.lastTime = 0;
            requestAnimationFrame((time) => this.gameLoop(time));
        }, 300); // Animation duration
    } else {
        this.board.set(boardWithPiece);
        this.spawnNewPiece();
        this.isHoldingAllowed.set(true);
    }
  }

  /**
   * Spawns the next piece at the top of the board. Ends the game if the new piece is invalid.
   */
  private spawnNewPiece(): void {
    this.dropCounter = 0;
    this.dropProgress.set(0);
    this.currentPiece.set(this.nextPiece());
    this.nextPiece.set(getRandomPiece());

    if (!isValidPosition(this.currentPiece()!, this.board())) {
        this.gameState.set('gameover');
    }
  }
  
  /**
   * Activates a specified power-up if available.
   * @param powerUp The power-up to activate.
   */
  activatePowerUp(powerUp: PowerUp): void {
      if (!this.canUsePowerUp(powerUp)) return;
      
      this.powerUps.update(p => ({...p, [powerUp]: p[powerUp] - 1}));

      switch(powerUp) {
          case 'laser':
            const piece = this.currentPiece();
            if(!piece) return;
            const y = Math.min(ROWS - 1, piece.y + piece.shape.length);
            this.board.update(b => {
                const newBoard = b.map(row => [...row]);
                newBoard[y] = new Array(COLS).fill(0);
                return newBoard;
            });
            break;
          case 'slow':
            this.slowMotionActive = true;
            setTimeout(() => this.slowMotionActive = false, 5000);
            break;
          case 'mutate':
            this.currentPiece.set(getRandomPiece());
            this.nextPiece.set(getRandomPiece());
            break;
          case 'aimer':
            this.isAiming.set(true);
            this.gameState.set('paused'); // Pause game loop
            this.updateAimerBoard();
            break;
      }
  }

  /**
   * Handles keyboard input when the 'aimer' power-up is active.
   * @param key The key that was pressed (e.g., 'ArrowLeft', 'Enter').
   */
  handleAimerKeys(key: string): void {
    if (!this.isAiming()) return;

    this.aimerPosition.update(pos => {
      let { x, y } = pos;
      if (key === 'ArrowLeft') x = Math.max(0, x - 1);
      if (key === 'ArrowRight') x = Math.min(COLS - 1, x + 1);
      if (key === 'ArrowUp') y = Math.max(0, y - 1);
      if (key === 'ArrowDown') y = Math.min(ROWS - 1, y + 1);
      return { x, y };
    });
    this.updateAimerBoard();

    if (key === 'Enter') {
      this.executeAimer();
    }
  }

  /**
   * Updates the visual representation of the aimer's target on the board.
   */
  private updateAimerBoard(): void {
    const { x, y } = this.aimerPosition();
    this.board.update(b => {
      const newBoard = b.map(row => row.map(cell => cell === -2 ? 0 : cell));
      if (newBoard[y][x] !== -2) {
        newBoard[y][x] = -2;
      }
      return newBoard;
    });
  }

  /**
   * Executes the 'aimer' power-up, destroying the targeted cell and applying gravity.
   */
  private executeAimer(): void {
    this.isAiming.set(false);
    this.gameState.set('playing');
    const { x, y } = this.aimerPosition();

    this.board.update(b => {
      const newBoard = b.map(row => row.map(cell => cell === -2 ? 0 : cell));
      newBoard[y][x] = 0; // Destroy cell
      applyGravityToColumn(newBoard, x);
      return newBoard;
    });
    
    this.lastTime = 0;
    requestAnimationFrame((time) => this.gameLoop(time));
  }

  /**
   * Toggles the animation mode between 'smooth' and 'step'.
   */
  toggleAnimationMode(): void {
    this.animationMode.update(current => current === 'smooth' ? 'step' : 'smooth');
  }

  /**
   * Handles the initial press of a key for movement, implementing DAS/ARR logic.
   * @param key The string identifier of the key that was pressed.
   */
  pressKey(key: string): void {
    switch (key) {
        case 'ArrowLeft':
        case 'ArrowRight':
            if (this.dasTimer || this.arrTimer) return;
            const move = () => key === 'ArrowLeft' ? this.moveLeft() : this.moveRight();
            move();
            this.dasTimer = setTimeout(() => {
                this.arrTimer = setInterval(move, this.arrInterval);
            }, this.dasDelay);
            break;
        case 'ArrowDown':
            if (this.softDropInterval) return;
            this.softDrop();
            this.softDropInterval = setInterval(() => this.softDrop(), this.arrInterval);
            break;
        case 'ArrowUp':
            this.rotate();
            break;
        case ' ': // Spacebar
            this.hardDrop();
            break;
        case 'c':
        case 'C':
            this.hold();
            break;
        case '1':
            this.activatePowerUp('laser');
            break;
        case '2':
            this.activatePowerUp('slow');
            break;
        case '3':
            this.activatePowerUp('mutate');
            break;
        case '4':
            this.activatePowerUp('aimer');
            break;
    }
  }

  /**
   * Handles the release of a key, clearing any related movement timers (DAS/ARR).
   * @param key The string identifier of the key that was released.
   */
  releaseKey(key: string): void {
    switch (key) {
        case 'ArrowLeft':
        case 'ArrowRight':
            clearTimeout(this.dasTimer);
            clearInterval(this.arrTimer);
            this.dasTimer = null;
            this.arrTimer = null;
            break;
        case 'ArrowDown':
            clearInterval(this.softDropInterval);
            this.softDropInterval = null;
            break;
    }
  }
}
--- END OF FILE: src/services/game.service.ts ---

--- START OF FILE: src/utils/board.utils.ts ---
/**
 * @fileoverview Utility functions related to the game board.
 */

import { COLS, ROWS } from './constants';

/**
 * Creates a new, empty game board matrix filled with zeros.
 * @returns A 2D number array representing the empty board.
 */
export function createEmptyBoard(): number[][] {
  return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
}

/**
 * Applies gravity to a single column after a cell has been removed.
 * This function mutates the board directly.
 * @param board The game board matrix to modify.
 * @param colIndex The index of the column to apply gravity to.
 */
export function applyGravityToColumn(board: number[][], colIndex: number): void {
    let emptyRow = -1;
    // Find the first empty cell from the bottom
    for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r][colIndex] === 0) {
            emptyRow = r;
            break;
        }
    }

    if (emptyRow === -1) return; // Column is full

    // Move cells down
    for (let r = emptyRow - 1; r >= 0; r--) {
        if (board[r][colIndex] !== 0) {
            board[emptyRow][colIndex] = board[r][colIndex];
            board[r][colIndex] = 0;
            emptyRow--;
        }
    }
}

--- END OF FILE: src/utils/board.utils.ts ---

--- START OF FILE: src/utils/constants.ts ---
/**
 * @fileoverview Defines constants used throughout the game.
 */

/** The number of columns on the game board. */
export const COLS = 10;
/** The number of rows on the game board. */
export const ROWS = 20;

/** The number of lines that must be cleared to advance to the next level. */
export const LEVEL_THRESHOLD = 10;

/**
 * A mapping of piece color indices to their corresponding Tailwind CSS background color classes.
 */
export const PIECE_COLORS: { [key: number]: string } = {
  1: 'cyan-400',    // I
  2: 'blue-600',    // J
  3: 'orange-500',  // L
  4: 'yellow-400',  // O
  5: 'green-500',   // S
  6: 'purple-600',  // T
  7: 'red-600',     // Z
};

--- END OF FILE: src/utils/constants.ts ---

--- START OF FILE: src/utils/game-logic.utils.ts ---
/**
 * @fileoverview Core game logic utilities for collision detection, line clearing, and scoring.
 */

import { Piece } from './piece.interface';
import { COLS, ROWS } from './constants';

/**
 * Checks if a piece's position is valid on the board (not out of bounds or colliding with other pieces).
 * @param piece The piece to validate.
 * @param board The current game board.
 * @returns `true` if the position is valid, `false` otherwise.
 */
export function isValidPosition(piece: Piece, board: number[][]): boolean {
  for (let y = 0; y < piece.shape.length; y++) {
    for (let x = 0; x < piece.shape[y].length; x++) {
      if (piece.shape[y][x] > 0) {
        const boardX = piece.x + x;
        const boardY = piece.y + y;

        // Check bounds
        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
          return false;
        }

        // Check for collision with existing pieces (only for cells within the board's visible area)
        if (boardY >= 0 && board[boardY] && board[boardY][boardX] > 0) {
          return false;
        }
      }
    }
  }
  return true;
}

/**
 * Removes completed lines from the board and adds new empty lines at the top.
 * @param board The board to process.
 * @returns An object containing the new board and the number of lines cleared.
 */
export function clearLines(board: number[][]): { boardAfterClear: number[][], lines: number } {
  let lines = 0;
  const newBoard = board.filter(row => {
    if (row.every(cell => cell > 0)) {
      lines++;
      return false; // This row is full, so filter it out
    }
    return true; // This row is not full, keep it
  });

  // Add new empty rows at the top to maintain board height
  while (newBoard.length < ROWS) {
    newBoard.unshift(Array(COLS).fill(0));
  }

  return { boardAfterClear: newBoard, lines };
}

/** Base points for clearing 0, 1, 2, 3, or 4 lines at once. */
const LINE_POINTS = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4 lines

/**
 * Calculates the score awarded for clearing lines.
 * @param linesCleared The number of lines cleared at once.
 * @param level The current game level.
 * @returns The calculated score.
 */
export function calculateScore(linesCleared: number, level: number): number {
  return (LINE_POINTS[linesCleared] || 0) * level;
}

--- END OF FILE: src/utils/game-logic.utils.ts ---

--- START OF FILE: src/utils/piece.interface.ts ---
/**
 * @fileoverview Defines the interface for a Tetris piece.
 */

/**
 * Represents a Tetris piece, including its position and shape.
 */
export interface Piece {
  /** The x-coordinate of the piece's top-left corner on the board. */
  x: number;
  /** The y-coordinate of the piece's top-left corner on the board. */
  y: number;
  /** A 2D number array representing the shape and color of the piece. */
  shape: number[][];
}

--- END OF FILE: src/utils/piece.interface.ts ---

--- START OF FILE: src/utils/piece.utils.ts ---
/**
 * @fileoverview Utility functions for creating and manipulating Tetris pieces.
 */

import { COLS } from './constants';
import { Piece } from './piece.interface';

/**
 * Defines the shapes and color indices of all available Tetris pieces.
 */
const PIECES = [
  { shape: [[1, 1, 1, 1]], color: 1 }, // I
  { shape: [[2, 0, 0], [2, 2, 2]], color: 2 }, // J
  { shape: [[0, 0, 3], [3, 3, 3]], color: 3 }, // L
  { shape: [[4, 4], [4, 4]], color: 4 }, // O
  { shape: [[0, 5, 5], [5, 5, 0]], color: 5 }, // S
  { shape: [[0, 6, 0], [6, 6, 6]], color: 6 }, // T
  { shape: [[7, 7, 0], [0, 7, 7]], color: 7 }, // Z
];

/**
 * Creates a new, randomly selected Tetris piece at the top-center of the board.
 * @returns A new Piece object.
 */
export function getRandomPiece(): Piece {
  const type = PIECES[Math.floor(Math.random() * PIECES.length)];
  
  // The shape matrix is populated with the color index instead of just '1'
  const shapeWithColor = type.shape.map(row => row.map(cell => (cell > 0 ? type.color : 0)));

  return {
    x: Math.floor(COLS / 2) - Math.floor(type.shape[0].length / 2),
    y: 0,
    shape: shapeWithColor,
  };
}

/**
 * Rotates a piece's shape matrix 90 degrees clockwise.
 * @param piece The piece to rotate.
 * @returns A new piece object with the rotated shape.
 */
export function rotate(piece: Piece): Piece {
    const shape = piece.shape;
    // Transpose and reverse rows to achieve rotation
    const newShape = shape[0].map((_, colIndex) => shape.map(row => row[colIndex]).reverse());
    return { ...piece, shape: newShape };
}

--- END OF FILE: src/utils/piece.utils.ts ---

--- START OF FILE: tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "files": [
    "./index.tsx"
  ],
  "angularCompilerOptions": {
    "disableTypeScriptVersionCheck": true
  }
}
--- END OF FILE: tsconfig.json ---

